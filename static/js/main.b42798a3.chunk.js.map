{"version":3,"sources":["Toolbox/Legend.js","../../core/src/random.ts","../../core/src/helperFunctions.ts","../../core/src/nelderMead.js","../../core/src/plyParser.ts","../../core/src/ellipsoid.ts","../../core/src/axon.ts","../../core/src/mapping.ts","../../core/src/BufferGeometryUtils.js","../../core/src/synthesizer.ts","Toolbox/SizeScale.js","Toolbox/Toolbox.js","Toolbox/config.js","Examples/Input.js","Examples/ParallelSameSize/ellipsoids.png","Examples/ParallelSameSize/pipesSide.png","Examples/ParallelSameSize/pipesFront.png","Examples/ParallelSameSize/index.js","Examples/ParallelDifferentSize/ellipsoids.png","Examples/ParallelDifferentSize/pipesSide.png","Examples/ParallelDifferentSize/pipesFront.png","Examples/ParallelDifferentSize/index.js","Examples/config.js","Examples/Examples.js","Examples/GettingStarted.js","Help/Cli.js","Help/config.js","Help/Help.js","Help/Setup.js","Help/AfterSetup.js","Help/Visual.js","Source/Source.js","config.js","Source/config.js","Menu.js","App.js","serviceWorkerRegistration.js","index.js"],"names":["_ref","colors","startTitle","midTitle","endTitle","height","width","_jsxs","className","style","children","_jsx","background","concat","join","rng","seedrandom","setRandomSeed","seed","String","randomPosition","Vector3","random","randomDirection","result","length","normalize","addMatrix3","a","b","Matrix3","fromArray","elements","map","e","i","mat3ToMat4","m","Matrix4","set","outerProduct","x","y","z","projectOntoCube","pos","dir","size","projectCoord","posCoord","dirCoord","s","scalar","Math","abs","clone","add","multiplyScalar","p1","p2","p3","dist1","sub","dot","dist2","dist3","collisionAxis","p","A","q","B","init","maxOverlap","axisOverlap","param","axis","extremum","ao","toArray","solution","func","start","fmin","nelderMead","fx","deform","shape","amount","multiply","applyMatrix3","transpose","axisLength","divideScalar","shuffle","j","floor","randomHexColor","toString","substr","hexColorToVector","color","Color","parseInt","applyColor","geometry","attributes","position","count","col","setAttribute","BufferAttribute","Float32Array","Array","fill","flat","scaledValueToColor","v","setHSL","valueToColor","value","min","max","getGeometry","geom","Geometry","fromBufferGeometry","geoms","options","verticesLength","facesLength","g","vertices","faces","dispose","header","binary","littleEndian","includeNormals","includeColors","filter","indexByteCount","headerBin","TextEncoder","encode","vertexListLength","faceListLength","output","DataView","ArrayBuffer","Uint8Array","buffer","offset","forEach","normals","f","c","index","vertexColors","vertexNormals","vertex","setFloat32","setUint8","indexOffset","setUint32","vertexList","faceList","push","includes","createEllipsoid","radius","deformation","minDiameter","movement","generateMesh","ellipsoid","id","v4","axisCache","diameter","cbrt","determinant","getColor","minAndMaxDiameter","getMatrix4","setPosition","SphereGeometry","applyMatrix4","computeVertexNormals","face","bg","BufferGeometry","fromGeometry","uv","mesh","Mesh","MeshToonMaterial","Object","assign","material","boundingBox","minDist","d","boundingBoxD","Box3","containsPoint","getInverse","keepInVoxel","voxelSize","getComponent","collision","ell","r","axisLengthNew","ratio","c1","c2","delta1","delta2","mu1","mu2","s1","s2","m1","m2","w","getOverlap","getSurfacePoint","inv","rLen","sqrt","grow","draw","scene","matrixAutoUpdate","matrix","updateMatrix","crossSectionDiameter","toPLY","simple","plyParser","computeCollisionTree","ellipsoids","aabb","slice","ceil","union","intersectsBox","f1","f2","generatePipeUtil","gRatio","resolution","viewSizes","getSP","scale","sp","_","dSmooth","sum","weight","dj","dist","exp","cx","cross","cy","verts","angle","PI","cos","sin","i2","sp2","Float32BufferAttribute","verti","setIndex","i00","i01","i10","i11","Face3","MeshPhongMaterial","side","DoubleSide","createAxon","ellipsoidSeparation","axon","end","negate","ellipsoidDensity","meshes","collisionTree","redistribute","getLength","ellipsoidCount","dLength","l","generatePipe","extended","firstPos","lastPos","n","applyAxisAngle","sign","ax","getMinAndMaxDiameter","contract","reduce","pMax","distMax","undefined","generatePipes","outer","inner","generateSkeleton","setFromPoints","Line","LineBasicMaterial","SphereBufferGeometry","InstancedMesh","setMatrixAt","toJSON","direction","maxDiameter","myelinDiameter","axonDiameter","map2","values","map1","v1","v2","k","map3","createMapping","from","to","xv","valuesInverse","mapInverse","BufferGeometryUtils","tolerance","arguments","Number","EPSILON","hashToIndex","indices","getIndex","positions","getAttribute","vertexCount","nextIndex","attributeNames","keys","attrArrays","morphAttrsArrays","newIndices","getters","name","morphAttr","morphAttributes","decimalShift","log10","shiftMultiplier","pow","getX","hash","attribute","itemSize","newarray","newMorphArrays","getterFunc","ml","oldAttribute","array","constructor","normalized","oldMorphAttribute","morphAttribute","wireframeCube","LineSegments","EdgesGeometry","BoxGeometry","linewidth","createSynthesizer","config","synthesizer","mapFromDiameterToDeformationFactor","mapFromMaxDiameterToMinDiameter","mapFromMaxDiameterToEllipsoidSeparation","axons","cells","updateState","progress","focus","type","object","minAndMaxDiameterAxons","minAndMaxDiameterCells","t","computeMinAndMaxDiameter","dAxons","dCells","cell","pairs","pair","volumeFraction","border","axonCount","cellCount","inside","drawLight","AmbientLight","light","DirectionalLight","drawVoxels","mode","drawAxons","drawCells","deselectAll","_c$mesh","addAxonsRandomly","console","log","addCellsRandomly","mo","update","growSpeed","contractSpeed","avf","cvf","voxelMode","axonMode","cellMode","Scene","point","camPos","cursorDir","_synthesizer$focus$ob","item","isAxon","props","helperFunctions","getHexString","Legend","toFixed","orientation","useStyles","makeStyles","theme","gridItem","padding","spacing","textAlign","title","path","component","windowWidth","windowHeight","useWindowSize","classes","mount","useRef","controls","setControls","useState","setScene","camera","setCamera","renderer","setRenderer","setSynthesizer","frame","setFrame","viewModeVoxel","setViewModeVoxel","viewModeAxon","setViewModeAxon","setViewSizes","setResolution","viewModeCell","setViewModeCell","setVolumeFraction","volumeFractionTarget","setVolumeFractionTarget","setSeed","setVoxelSize","setAxonCount","setCellCount","setGrowSpeed","setContractSpeed","setMinDist","inputFileRef","inputFile","setInputFile","setUpdateState","growCount","setGrowCount","growCountTarget","setGrowCountTarget","automaticGrowth","setAutomaticGrowth","setMapFromDiameterToDeformationFactor","setMapFromMaxDiameterToMinDiameter","setMapFromMaxDiameterToEllipsoidSeparation","selectItem","setSelectItem","selectedItem","setSelectedItem","exportBinary","setExportBinary","exportSimple","setExportSimple","setBorder","setGRatio","useEffect","mc","current","cam","PerspectiveCamera","lookAt","ren","WebGLRenderer","antialias","setClearColor","setSize","appendChild","domElement","ctrls","OrbitControls","enableDamping","dampingFactor","window","setInterval","clearInterval","removeChild","renderLists","mousemove","offsetX","tan","offsetY","forward","right","up","click","prompt","download","replace","addEventListener","removeEventListener","render","JSON","stringify","gc","us","setTimeout","reader","FileReader","onload","event","data","parse","target","isNaN","randomSeed","minimumDistance","readAsText","_Fragment","Grid","container","xs","innerHeight","overflowX","overflowY","Paper","List","ListItem","TextField","label","InputProps","endAdornment","InputAdornment","onChange","Button","variant","onClick","ref","display","files","TableContainer","Table","table","TableBody","TableRow","TableCell","scope","FormControl","InputLabel","Select","vm","MenuItem","res","FormControlLabel","control","Switch","checked","vs","async","wait","Promise","resolve","downloadPLY","SizeScale","inputExample","img","items","Route","match","content","Link","Typography","save","src","imgEllipsoids","alt","imgPipesSide","imgPipesFront","Code","fontFamily","backgroundColor","fontSize","source","toolbox","examples","help","href","root","drawer","breakpoints","flexShrink","drawerPaper","flexGrow","nested","paddingLeft","history","useHistory","Drawer","paper","disablePadding","subheader","ListSubheader","button","selected","url","ListItemText","primary","CssBaseline","BrowserRouter","Menu","Redirect","exact","isLocalhost","Boolean","location","hostname","registerValidSW","swUrl","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","onUpdate","onSuccess","catch","error","ReactDOM","React","StrictMode","App","document","getElementById","URL","process","origin","fetch","headers","response","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker","serviceWorkerRegistration"],"mappings":"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","file":"static/js/main.b42798a3.chunk.js","sourcesContent":["import React from \"react\";\n\nexport default ({ colors, startTitle, midTitle, endTitle, height, width }) => (\n    <div className={\"rv-continuous-color-legend\"} style={{ width, height }}>\n        <div className=\"rv-gradient\" style={{ background: `linear-gradient(to right, ${colors.join(\",\")})` }} />\n        <div className=\"rv-legend-titles\">\n            <span className=\"rv-legend-titles__left\">{startTitle}</span>\n            <span className=\"rv-legend-titles__right\">{endTitle}</span>\n            {midTitle ? <span className=\"rv-legend-titles__center\">{midTitle}</span> : null}\n        </div>\n    </div>\n);\n","import seedrandom from \"seedrandom\";\n\nlet rng = seedrandom(\"0\");\n\nexport const setRandomSeed = (seed: number) => {\n    rng = seedrandom(String(seed));\n};\n\nexport default () => rng();\n","import { Vector3, Matrix3, Matrix4, BufferAttribute, Color, BufferGeometry } from \"three\";\nimport random from \"./random\";\nimport nelderMead from \"./nelderMead\";\n\nexport const randomPosition = () => new Vector3(random() - 0.5, random() - 0.5, random() - 0.5);\n\nexport const randomDirection = (): Vector3 => {\n    const result = new Vector3(2 * random() - 1, 2 * random() - 1, 2 * random() - 1);\n    if (result.length() < 0.00001) return randomDirection();\n    return result.normalize();\n};\n\nexport const addMatrix3 = (a: Matrix3, b: Matrix3) =>\n    new Matrix3().fromArray(a.elements.map((e, i) => e + b.elements[i]));\n\nexport const mat3ToMat4 = (m: Matrix3) =>\n    new Matrix4().set(\n        m.elements[0],\n        m.elements[1],\n        m.elements[2],\n        0,\n        m.elements[3],\n        m.elements[4],\n        m.elements[5],\n        0,\n        m.elements[6],\n        m.elements[7],\n        m.elements[8],\n        0,\n        0,\n        0,\n        0,\n        1\n    );\n\nexport const outerProduct = (a: Vector3, b: Vector3) =>\n    new Matrix3().set(\n        a.x * b.x,\n        a.x * b.y,\n        a.x * b.z,\n        a.y * b.x,\n        a.y * b.y,\n        a.y * b.z,\n        a.z * b.x,\n        a.z * b.y,\n        a.z * b.z\n    );\n\nexport const projectOntoCube = (pos: Vector3, dir: Vector3, size: Vector3) => {\n    const projectCoord = (pos: Vector3, dir: Vector3, posCoord: number, dirCoord: number, s: number) => {\n        const scalar = Math.abs(dirCoord) < 0.00001 ? 1e10 : (((dirCoord > 0 ? 1 : -1) * s) / 2 - posCoord) / dirCoord;\n        return pos.clone().add(dir.clone().multiplyScalar(scalar));\n    };\n    const p1 = projectCoord(pos, dir, pos.x, dir.x, size.x);\n    const p2 = projectCoord(pos, dir, pos.y, dir.y, size.y);\n    const p3 = projectCoord(pos, dir, pos.z, dir.z, size.z);\n    const dist1 = p1.clone().sub(pos).dot(dir);\n    const dist2 = p2.clone().sub(pos).dot(dir);\n    const dist3 = p3.clone().sub(pos).dot(dir);\n    if (dist1 < dist2 && dist1 < dist3) return p1;\n    if (dist2 < dist3) return p2;\n    return p3;\n};\n\nexport const collisionAxis = (p: Vector3, A: Matrix3, q: Vector3, B: Matrix3, init: Vector3, maxOverlap: number) => {\n    const axisOverlap = (param: number[]) => {\n        const axis = new Vector3().fromArray(param).normalize();\n        return p.clone().sub(q).add(extremum(A, axis)).add(extremum(B, axis)).dot(axis);\n    };\n    if (init) {\n        const ao = axisOverlap(init.toArray());\n        if (ao < maxOverlap) return [ao, init];\n    }\n    const solution = nelderMead(axisOverlap, (init || q.clone().sub(p).normalize()).toArray());\n    return [solution.fx, new Vector3().fromArray(solution.x).normalize()];\n};\n\nexport const deform = (shape: Matrix3, axis: Vector3, amount: number) =>\n    shape.multiply(addMatrix3(outerProduct(axis, axis).multiplyScalar(amount / axis.dot(axis)), new Matrix3()));\n\nexport const extremum = (shape: Matrix3, axis: Vector3) => {\n    const a = axis.clone();\n    a.applyMatrix3(shape.clone().transpose());\n    const axisLength = a.length();\n    if (axisLength > 0.00001) a.divideScalar(axisLength);\n    return a.applyMatrix3(shape);\n};\n\nexport const shuffle = <T>(a: T[]) => {\n    for (let i = a.length - 1; i > 0; i--) {\n        const j = Math.floor(random() * (i + 1));\n        [a[i], a[j]] = [a[j], a[i]];\n    }\n    return a;\n};\n\nexport const randomHexColor = () => \"#\" + random().toString(16).substr(2, 6);\n\nexport const hexColorToVector = (color: string) =>\n    new Color(\n        parseInt(color.substr(1, 6).substr(0, 2), 16) / 255,\n        parseInt(color.substr(1, 6).substr(2, 2), 16) / 255,\n        parseInt(color.substr(1, 6).substr(4, 2), 16) / 255\n    );\n\nexport const applyColor = (geometry: BufferGeometry, color: string) => {\n    if (!(((geometry || {}).attributes || {}).position || {}).count) return geometry;\n    const col = hexColorToVector(color);\n    return geometry.setAttribute(\n        \"color\",\n        new BufferAttribute(new Float32Array(Array(geometry.attributes.position.count).fill(col.toArray()).flat()), 3)\n    );\n};\n\nexport const scaledValueToColor = (v: number) => new Color().setHSL((1 - v) * (2 / 3), 1, 0.5);\n\nexport const valueToColor = (value: number, { min, max }: { min: number; max: number }) =>\n    scaledValueToColor((value - min) / (max - min));\n","import fmin from \"fmin\";\n\nexport default (func, start) => fmin.nelderMead(func, start);\n","import { Vector3, Color, Geometry, BufferGeometry } from \"three\";\n\nconst getGeometry = (geom: BufferGeometry) => new Geometry().fromBufferGeometry(geom);\n\ntype Options = {\n    binary: boolean;\n    littleEndian: boolean;\n    includeNormals: boolean;\n    includeColors: boolean;\n};\n\nexport default (geoms: BufferGeometry[], options: Options) => {\n    let verticesLength = 0;\n    let facesLength = 0;\n    for (let i = 0; i < geoms.length; ++i) {\n        const g = getGeometry(geoms[i]);\n        verticesLength += g.vertices.length;\n        facesLength += g.faces.length;\n        g.dispose();\n    }\n    const header = [\n        `ply`,\n        `format ${\n            options.binary ? (options.littleEndian ? \"binary_little_endian\" : \"binary_big_endian\") : \"ascii\"\n        } 1.0`,\n        `element vertex ${verticesLength}`,\n        `property float x`,\n        `property float y`,\n        `property float z`,\n        options.includeNormals ? \"property float nx\\nproperty float ny\\nproperty float nz\" : \"\",\n        options.includeColors ? \"property uchar red\\nproperty uchar green\\nproperty uchar blue\" : \"\",\n        `element face ${facesLength}`,\n        `property list uchar int vertex_index`,\n        `end_header`\n    ]\n        .filter(s => s !== \"\")\n        .join(\"\\n\");\n    if (options.binary) {\n        const indexByteCount = 4;\n        const headerBin = new TextEncoder().encode(header + \"\\n\");\n        const vertexListLength =\n            verticesLength * (4 * 3 + (options.includeNormals ? 4 * 3 : 0) + (options.includeColors ? 3 : 0));\n        const faceListLength = facesLength * (indexByteCount * 3 + 1);\n        const output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));\n        new Uint8Array(output.buffer).set(headerBin, 0);\n        let offset = headerBin.length;\n        geoms.forEach(geom => {\n            const g = getGeometry(geom);\n            const colors = g.vertices.map(() => new Color(1, 1, 1));\n            const normals = g.vertices.map(() => new Vector3(0, 0, 0));\n            g.faces.forEach(f =>\n                [f.a, f.b, f.c].forEach((index, i) => {\n                    colors[index] = f.vertexColors[i];\n                    normals[index] = f.vertexNormals[i];\n                })\n            );\n\n            g.vertices.forEach((vertex, i) => {\n                vertex.toArray().forEach(v => {\n                    output.setFloat32(offset, v, options.littleEndian);\n                    offset += 4;\n                });\n                if (options.includeNormals)\n                    normals[i].toArray().forEach(v => {\n                        output.setFloat32(offset, v, options.littleEndian);\n                        offset += 4;\n                    });\n                if (options.includeColors)\n                    colors[i].toArray().forEach(v => {\n                        output.setUint8(offset, Math.floor(v * 255));\n                        offset += 1;\n                    });\n            });\n            g.dispose();\n        });\n        let indexOffset = 0;\n        geoms.forEach(geom => {\n            const g = getGeometry(geom);\n            g.faces.forEach(f => {\n                output.setUint8(offset, 3);\n                offset += 1;\n                [f.a, f.b, f.c].forEach(v => {\n                    output.setUint32(offset, indexOffset + v, options.littleEndian);\n                    offset += indexByteCount;\n                });\n            });\n            indexOffset += g.vertices.length;\n            g.dispose();\n        });\n        return output.buffer;\n    } else {\n        let indexOffset = 0;\n        const vertexList: string[][] = [];\n        const faceList: string[][] = [];\n        geoms.forEach(geom => {\n            const g = getGeometry(geom);\n            const colors = g.vertices.map(() => new Color(1, 1, 1));\n            const normals = g.vertices.map(() => new Vector3(0, 0, 0));\n            g.faces.forEach(f =>\n                [f.a, f.b, f.c].forEach((index, i) => {\n                    colors[index] = f.vertexColors[i];\n                    normals[index] = f.vertexNormals[i];\n                })\n            );\n            vertexList.push(\n                g.vertices.map((vertex, i) =>\n                    [\n                        [vertex.toArray(), options.includeNormals ? normals[i].toArray() : []]\n                            .flat()\n                            .map(v => v.toString())\n                            .map(v => {\n                                if (v.includes(\".\")) return v;\n                                return v + \".0\";\n                            }),\n                        options.includeColors ? colors[i].toArray().map(c => Math.floor(c * 255)) : []\n                    ]\n                        .flat()\n                        .join(\" \")\n                )\n            );\n            faceList.push(g.faces.map(f => `3 ${indexOffset + f.a} ${indexOffset + f.b} ${indexOffset + f.c}`));\n            indexOffset += g.vertices.length;\n            g.dispose();\n        });\n        return [header, vertexList.flat().join(\"\\n\"), faceList.flat().join(\"\\n\")].join(\"\\n\");\n    }\n};\n","import {\n    Vector3,\n    Matrix3,\n    Matrix4,\n    Box3,\n    SphereGeometry,\n    Mesh,\n    MeshToonMaterial,\n    Geometry,\n    BufferGeometry,\n    Scene,\n    Color\n} from \"three\";\nimport { v4 } from \"uuid\";\nimport {\n    addMatrix3,\n    collisionAxis,\n    deform,\n    extremum,\n    hexColorToVector,\n    mat3ToMat4,\n    randomDirection,\n    randomHexColor,\n    valueToColor\n} from \"./helperFunctions\";\nimport plyParser from \"./plyParser\";\nimport { Mapping } from \"./mapping\";\n\nexport interface EllipsoidJSON {\n    position: number[];\n    shape: number[];\n}\n\nexport interface CellJSON extends EllipsoidJSON {\n    color: string;\n}\n\ninterface EllipsoidState {\n    pos: Vector3;\n    radius: number;\n    deformation: Mapping;\n    minDiameter: Mapping;\n    movement: number;\n    id: string;\n    shape: Matrix3;\n    color: string;\n    axisCache: { [id: string]: Vector3 };\n    mesh?: Mesh;\n}\n\nexport interface Ellipsoid extends EllipsoidState {\n    dispose: () => void;\n    clone: () => Ellipsoid;\n    boundingBox: (minDist: number) => Box3;\n    containsPoint: (p: Vector3) => boolean;\n    keepInVoxel: (voxelSize: Vector3, minDist: number) => void;\n    collision: (ell: Ellipsoid, minDist: number, maxOverlap: number) => void;\n    getOverlap: (ell: Ellipsoid, minDist: number, maxOverlap: number) => number;\n    getSurfacePoint: (pos: Vector3, dir: Vector3) => Vector3 | undefined;\n    grow: (amount: number) => void;\n    getColor: (minAndMaxDiameter: { min: number; max: number } | null) => Color;\n    draw: (scene: Scene, generateMesh: boolean, minAndMaxDiameter: { min: number; max: number }) => Mesh | undefined;\n    getMatrix4: () => Matrix4;\n    diameter: () => number;\n    crossSectionDiameter: (axis: Vector3) => number;\n    toPLY: (binary: boolean, simple: boolean) => string | ArrayBuffer;\n}\n\nconst createEllipsoid = (\n    pos: Vector3,\n    radius: number,\n    deformation: Mapping,\n    minDiameter: Mapping,\n    movement: number,\n    color: string | undefined,\n    generateMesh: boolean\n): Ellipsoid => {\n    const ellipsoid: EllipsoidState = {\n        pos: pos.clone(),\n        radius,\n        deformation,\n        minDiameter,\n        movement,\n        id: v4(),\n        shape: new Matrix3().multiplyScalar(minDiameter.map(radius * 2) / 2),\n        color: color || randomHexColor(),\n        axisCache: {}\n    };\n    const dispose = () => {\n        if (!ellipsoid.mesh) return;\n        ellipsoid.mesh.geometry.dispose();\n        [ellipsoid.mesh.material].flat().map(m => m.dispose());\n    };\n    const clone = () => {\n        const result = createEllipsoid(\n            ellipsoid.pos,\n            ellipsoid.radius,\n            ellipsoid.deformation,\n            ellipsoid.minDiameter,\n            ellipsoid.movement,\n            ellipsoid.color,\n            !!ellipsoid.mesh\n        );\n        result.shape = ellipsoid.shape;\n        return result;\n    };\n    const boundingBoxD = (minDist: number) => {\n        const x = extremum(ellipsoid.shape, new Vector3(1, 0, 0)).dot(new Vector3(1, 0, 0));\n        const y = extremum(ellipsoid.shape, new Vector3(0, 1, 0)).dot(new Vector3(0, 1, 0));\n        const z = extremum(ellipsoid.shape, new Vector3(0, 0, 1)).dot(new Vector3(0, 0, 1));\n        return new Vector3(x + minDist / 2, y + minDist / 2, z + minDist / 2);\n    };\n    const boundingBox = (minDist: number) => {\n        const d = boundingBoxD(minDist);\n        return new Box3(ellipsoid.pos.clone().sub(d), ellipsoid.pos.clone().add(d));\n    };\n    const containsPoint = (p: Vector3) => {\n        return p.clone().sub(ellipsoid.pos).applyMatrix3(new Matrix3().getInverse(ellipsoid.shape)).length() < 1;\n    };\n    const keepInVoxel = (voxelSize: Vector3, minDist: number) => {\n        ellipsoid.pos.fromArray(\n            ellipsoid.pos\n                .toArray()\n                .map((v, i) => Math.min(Math.max(v, -voxelSize.getComponent(i) / 2), voxelSize.getComponent(i) / 2))\n        );\n    };\n    const collision = (ell: Ellipsoid, minDist: number, maxOverlap: number) => {\n        const d = ell.pos.clone().sub(ellipsoid.pos);\n        const dSqr = d.dot(d);\n        if (dSqr < 0.00001) {\n            const r = randomDirection().multiplyScalar(0.0001);\n            ellipsoid.pos.sub(r);\n            ell.pos.add(r);\n            return;\n        }\n        const [axisLength, axis] = collisionAxis(\n            ellipsoid.pos,\n            ellipsoid.shape,\n            ell.pos,\n            ell.shape,\n            ellipsoid.axisCache[ell.id],\n            maxOverlap\n        );\n        ellipsoid.axisCache[ell.id] = axis;\n        let axisLengthNew = axisLength + minDist;\n        if (axisLengthNew < 0) return;\n        const ratio = ell.radius / ellipsoid.radius;\n        // Collision resolution\n        // Update shape\n        const c1 = extremum(ellipsoid.shape, axis).dot(axis);\n        const c2 = extremum(ell.shape, axis).dot(axis);\n        const delta1 = (ellipsoid.deformation.map(c1 * 2) / (c1 * 2)) * Math.min(ratio, 1);\n        const delta2 = (ell.deformation.map(c2 * 2) / (c2 * 2)) * Math.min(1 / ratio, 1);\n        const mu1 = ellipsoid.minDiameter.map(ellipsoid.radius * 2) / (c1 * 2);\n        const mu2 = ell.minDiameter.map(ell.radius * 2) / (c2 * 2);\n        const s1 = Math.max(-axisLengthNew * delta1, mu1 - 1);\n        const s2 = Math.max(-axisLengthNew * delta2, mu2 - 1);\n        deform(ellipsoid.shape, axis, s1);\n        deform(ell.shape, axis, s2);\n        axisLengthNew += s1 * c1 + s2 * c2;\n        // Update position\n        const m1 = ellipsoid.movement * ratio;\n        const m2 = ell.movement;\n        const w = axisLengthNew / (m1 + m2);\n        ellipsoid.pos.sub(axis.clone().multiplyScalar(m1 * w));\n        ell.pos.add(axis.clone().multiplyScalar(m2 * w));\n    };\n    const getOverlap = (ell: Ellipsoid, minDist: number, maxOverlap: number) => {\n        const [axisLength, axis] = collisionAxis(\n            ellipsoid.pos,\n            ellipsoid.shape,\n            ell.pos,\n            ell.shape,\n            ellipsoid.axisCache[ell.id],\n            maxOverlap\n        );\n        ellipsoid.axisCache[ell.id] = axis;\n        return Math.max(axisLength + minDist, 0);\n    };\n    const getSurfacePoint = (pos: Vector3, dir: Vector3) => {\n        const inv = new Matrix3().getInverse(ellipsoid.shape);\n        const p = pos.clone().sub(ellipsoid.pos).applyMatrix3(inv);\n        const d = dir.clone().applyMatrix3(inv);\n        d.normalize();\n        const r = p.clone().sub(d.clone().multiplyScalar(d.dot(p)));\n        const rLen = r.length();\n        if (rLen > 1) return undefined;\n        const x = d.multiplyScalar(Math.sqrt(1 - rLen ** 2));\n        return r.clone().add(x).applyMatrix3(ellipsoid.shape).add(ellipsoid.pos);\n    };\n    const grow = (amount: number) => {\n        if (amount >= 0)\n            ellipsoid.shape = addMatrix3(\n                ellipsoid.shape.multiplyScalar(1 - amount),\n                new Matrix3().multiplyScalar(ellipsoid.radius * amount)\n            );\n        else\n            ellipsoid.shape = addMatrix3(\n                ellipsoid.shape.multiplyScalar(1 + amount),\n                new Matrix3().multiplyScalar((-amount * ellipsoid.minDiameter.map(ellipsoid.radius * 2)) / 2)\n            );\n    };\n    const diameter = () => {\n        return 2 * Math.cbrt(ellipsoid.shape.determinant());\n    };\n    const getColor = (minAndMaxDiameter: { min: number; max: number } | null) => {\n        return minAndMaxDiameter ? valueToColor(diameter(), minAndMaxDiameter) : hexColorToVector(ellipsoid.color);\n    };\n    const getMatrix4 = () => {\n        return mat3ToMat4(ellipsoid.shape).setPosition(ellipsoid.pos);\n    };\n    const getGeometry = (minAndMaxDiameter: { min: number; max: number } | null) => {\n        const geom = new SphereGeometry(1, 16, 16).applyMatrix4(getMatrix4());\n        geom.computeVertexNormals();\n        const color = getColor(minAndMaxDiameter);\n        geom.faces.forEach(face => (face.vertexColors = new Array(3).fill(true).map(() => color)));\n        const bg = new BufferGeometry().fromGeometry(geom);\n        delete bg.attributes.uv;\n        return bg;\n    };\n    const draw = (scene: Scene, generateMesh: boolean, minAndMaxDiameter: { min: number; max: number }) => {\n        const g = getGeometry(minAndMaxDiameter);\n        if (generateMesh) ellipsoid.mesh = new Mesh(g, new MeshToonMaterial({ color: getColor(minAndMaxDiameter) }));\n        if (!ellipsoid.mesh) return undefined;\n        ellipsoid.mesh.geometry = g;\n        ellipsoid.mesh.matrixAutoUpdate = false;\n        ellipsoid.mesh.matrix = getMatrix4();\n        ellipsoid.mesh.updateMatrix();\n        scene.add(ellipsoid.mesh);\n        return ellipsoid.mesh;\n    };\n    const crossSectionDiameter = (axis: Vector3) => {\n        axis.normalize();\n        return 2 * Math.sqrt(ellipsoid.shape.determinant() / extremum(ellipsoid.shape, axis).dot(axis));\n    };\n    const toPLY = (binary: boolean, simple: boolean) => {\n        if (!ellipsoid.mesh) return \"\";\n        const geometry = ellipsoid.mesh.geometry;\n        const geom = geometry instanceof Geometry ? new BufferGeometry().fromGeometry(geometry) : geometry;\n        return plyParser([geom], {\n            binary: binary,\n            includeColors: !simple,\n            includeNormals: !simple,\n            littleEndian: false\n        });\n    };\n    if (generateMesh) ellipsoid.mesh = new Mesh(getGeometry(null), new MeshToonMaterial({ color: ellipsoid.color }));\n    return Object.assign(ellipsoid, {\n        dispose,\n        clone,\n        boundingBox,\n        containsPoint,\n        keepInVoxel,\n        collision,\n        getOverlap,\n        getSurfacePoint,\n        grow,\n        getColor,\n        draw,\n        getMatrix4,\n        diameter,\n        crossSectionDiameter,\n        toPLY\n    });\n};\n\nexport default createEllipsoid;\n","import {\n    Vector3,\n    Box3,\n    MeshPhongMaterial,\n    LineBasicMaterial,\n    BufferGeometry,\n    Line,\n    Mesh,\n    SphereBufferGeometry,\n    DoubleSide,\n    Geometry,\n    Face3,\n    InstancedMesh,\n    BufferAttribute,\n    Float32BufferAttribute,\n    Scene\n} from \"three\";\nimport {\n    addMatrix3,\n    applyColor,\n    hexColorToVector,\n    projectOntoCube,\n    randomHexColor,\n    valueToColor\n} from \"./helperFunctions\";\nimport random from \"./random\";\nimport createEllipsoid from \"./ellipsoid\";\nimport plyParser from \"./plyParser\";\nimport { Ellipsoid, EllipsoidJSON } from \"./ellipsoid\";\nimport { Mapping } from \"./mapping\";\n\ntype CollisionTree = {\n    a?: CollisionTree;\n    b?: CollisionTree;\n    ellipsoid?: Ellipsoid;\n    aabb: Box3;\n    containsPoint: (p: Vector3) => boolean;\n};\n\nconst computeCollisionTree = (ellipsoids: Ellipsoid[], minDist: number): CollisionTree => {\n    if (ellipsoids.length === 1)\n        return {\n            ellipsoid: ellipsoids[0],\n            aabb: ellipsoids[0].boundingBox(minDist),\n            containsPoint: p => ellipsoids[0].containsPoint(p)\n        };\n    const a = computeCollisionTree(ellipsoids.slice(0, Math.ceil(ellipsoids.length / 2)), minDist);\n    const b = computeCollisionTree(ellipsoids.slice(Math.ceil(ellipsoids.length / 2)), minDist);\n    const aabb = a.aabb.clone().union(b.aabb);\n    return {\n        a: a,\n        b: b,\n        aabb: aabb,\n        containsPoint: p => {\n            if (!aabb.containsPoint(p)) return false;\n            return a.containsPoint(p) || b.containsPoint(p);\n        }\n    };\n};\n\nconst collision = (a: CollisionTree, b: CollisionTree, minDist: number, maxOverlap: number): void => {\n    if (!a.aabb.intersectsBox(b.aabb)) return;\n    if (b.ellipsoid) {\n        if (a.ellipsoid) return a.ellipsoid.collision(b.ellipsoid, minDist, maxOverlap);\n        return collision(b, a, minDist, maxOverlap);\n    }\n    const f1 = () => {\n        if (b.a) collision(b.a, a, minDist, maxOverlap);\n    };\n    const f2 = () => {\n        if (b.b) collision(b.b, a, minDist, maxOverlap);\n    };\n    if (random() < 0.5) {\n        f1();\n        f2();\n    } else {\n        f2();\n        f1();\n    }\n};\n\nconst getOverlap = (a: CollisionTree, b: CollisionTree, minDist: number, maxOverlap: number): number => {\n    if (!a.aabb.intersectsBox(b.aabb)) return 0;\n    if (b.ellipsoid) {\n        if (a.ellipsoid) return a.ellipsoid.getOverlap(b.ellipsoid, minDist, maxOverlap);\n        return getOverlap(b, a, minDist, maxOverlap);\n    }\n    if (!b.a || !b.b) return 0;\n    return Math.max(getOverlap(b.a, a, minDist, maxOverlap), getOverlap(b.b, a, minDist, maxOverlap));\n};\n\nconst generatePipeUtil = (\n    ellipsoids: Ellipsoid[],\n    color: string,\n    gRatio: number,\n    resolution: number,\n    viewSizes: boolean,\n    minAndMaxDiameter: { min: number; max: number }\n) => {\n    const getSP = (pos: Vector3, dir: Vector3, i: number, scale: number) => {\n        const shape = ellipsoids[i].shape;\n        ellipsoids[i].shape = shape.clone().multiplyScalar(scale);\n        const sp = ellipsoids[i].getSurfacePoint(pos, dir);\n        ellipsoids[i].shape = shape;\n        return sp;\n    };\n    const d = ellipsoids\n        .map((_, i) =>\n            ellipsoids[Math.min(i + 1, ellipsoids.length - 1)].pos.clone().sub(ellipsoids[Math.max(i - 1, 0)].pos)\n        )\n        .map(d => d.normalize());\n    const sd = 0.05;\n    const dSmooth = d.map((_, i) => {\n        const sum = new Vector3(0, 0, 0);\n        let weight = 0;\n        d.forEach((dj, j) => {\n            const dist = Math.abs((i - j) / d.length);\n            const w = Math.exp(-0.5 * (dist / sd) ** 2);\n            sum.add(d[j].clone().multiplyScalar(w));\n            weight += w;\n        });\n        return sum.multiplyScalar(1 / weight);\n    });\n\n    const x = new Vector3(1, 0, 0);\n    const y = new Vector3(0, 1, 0);\n    const cx = dSmooth[0].clone().cross(x);\n    const cy = dSmooth[0].clone().cross(y);\n    const a = [...Array(dSmooth.length)].map(() => new Vector3(0, 0, 0));\n    dSmooth.forEach((_, i) => {\n        if (i === 0) {\n            a[i] = cx.length() > cy.length() ? cx : cy;\n            return;\n        }\n        a[i] = dSmooth[i - 1]\n            .clone()\n            .cross(a[i - 1])\n            .cross(dSmooth[i])\n            .normalize();\n    });\n    const verts = ellipsoids.map((ellipsoid, i) => {\n        const b = dSmooth[i].clone().cross(a[i]).normalize();\n        return [...Array(resolution)].map((r, j) => {\n            const angle = (2 * Math.PI * j) / resolution;\n            const dir = a[i]\n                .clone()\n                .multiplyScalar(Math.cos(angle))\n                .add(b.clone().multiplyScalar(Math.sin(angle)));\n            let sp = getSP(ellipsoid.pos, dir, i, gRatio) || new Vector3(0, 0, 0);\n            let dist = sp.clone().sub(ellipsoid.pos).dot(dir);\n            for (let i2 = i + 1; i2 < ellipsoids.length; ++i2) {\n                const sp2 = getSP(ellipsoid.pos, dir, i2, gRatio);\n                if (!sp2) break;\n                const dist2 = sp2.clone().sub(ellipsoid.pos).dot(dir);\n                if (dist2 < dist) continue;\n                sp = sp2;\n                dist = dist2;\n            }\n            for (let i2 = i - 1; i2 >= 0; --i2) {\n                const sp2 = getSP(ellipsoid.pos, dir, i2, gRatio);\n                if (!sp2) break;\n                const dist2 = sp2.clone().sub(ellipsoid.pos).dot(dir);\n                if (dist2 < dist) continue;\n                sp = sp2;\n                dist = dist2;\n            }\n            return sp;\n        });\n    });\n    const geom = new BufferGeometry();\n    geom.setAttribute(\n        \"position\",\n        new Float32BufferAttribute(\n            verts\n                .flat()\n                .map(v => v.toArray())\n                .flat(),\n            3\n        )\n    );\n    geom.setAttribute(\n        \"color\",\n        new Float32BufferAttribute(\n            verts\n                .map((verti, i) =>\n                    verti.map(() =>\n                        (viewSizes\n                            ? valueToColor(\n                                  ellipsoids[i].crossSectionDiameter(\n                                      ellipsoids[Math.min(i + 1, ellipsoids.length - 1)].pos\n                                          .clone()\n                                          .sub(ellipsoids[Math.max(i - 1, 0)].pos)\n                                  ),\n                                  minAndMaxDiameter\n                              )\n                            : hexColorToVector(color)\n                        ).toArray()\n                    )\n                )\n                .flat()\n                .flat(),\n            3\n        )\n    );\n    geom.setIndex(\n        verts\n            .slice(0, verts.length - 1)\n            .map((verti, i) => {\n                return verti.map((_, j) => {\n                    const i00 = i * resolution + j;\n                    const i01 = i * resolution + ((j + 1) % resolution);\n                    const i10 = (i + 1) * resolution + j;\n                    const i11 = (i + 1) * resolution + ((j + 1) % resolution);\n                    const a = new Face3(i00, i01, i10);\n                    const b = new Face3(i10, i01, i11);\n                    return [a, b];\n                });\n            })\n            .flat()\n            .flat()\n            .map(v => [v.a, v.b, v.c])\n            .flat()\n    );\n    geom.computeVertexNormals();\n    const bg = geom;\n    const result = new Mesh(bg, new MeshPhongMaterial({ vertexColors: true, side: DoubleSide }));\n    geom.dispose();\n    bg.dispose();\n    return result;\n};\n\nexport type AxonJSON = {\n    position: number[];\n    direction: number[];\n    maxDiameter: number;\n    color: string;\n    gRatio: number;\n    ellipsoids: EllipsoidJSON[];\n};\n\ninterface AxonState {\n    start: Vector3;\n    end: Vector3;\n    gRatio: number;\n    ellipsoidDensity: number;\n    voxelSize: Vector3;\n    deformation: Mapping;\n    minDiameter: Mapping;\n    color: string;\n    meshes: (Mesh | Line)[];\n    radius: number;\n    ellipsoids: Ellipsoid[];\n    collisionTree: CollisionTree;\n}\n\nexport interface Axon extends AxonState {\n    dispose: () => void;\n    keepInVoxel: (minDist: number) => void;\n    computeCollisionTree: (minDist: number) => void;\n    collision: (ax: Axon, minDist: number, maxOverlap: number) => void;\n    getOverlap: (ax: Axon, minDist: number, maxOverlap: number) => number;\n    getMinAndMaxDiameter: () => { min: number; max: number };\n    grow: (amount: number) => void;\n    contract: (amount: number) => void;\n    redistribute: () => void;\n    getLength: () => number;\n    getSurfacePoint: (pos: Vector3, dir: Vector3) => Vector3 | undefined;\n    generatePipe: (\n        gRatio: number,\n        resolution: number,\n        extended: boolean,\n        viewSizes: boolean,\n        minAndMaxDiameter: { min: number; max: number }\n    ) => Mesh;\n    generatePipes: (\n        scene: Scene,\n        resolution: number,\n        extended: boolean,\n        viewSizes: boolean,\n        minAndMaxDiameter: { min: number; max: number }\n    ) => void;\n    generateSkeleton: (scene: Scene, viewSizes: boolean, minAndMaxDiameter: { min: number; max: number }) => void;\n    draw: (scene: Scene, viewSizes: boolean, minAndMaxDiameter: { min: number; max: number }) => void;\n    toJSON: () => AxonJSON;\n    toPLY: (binary: boolean, simple: boolean, i: number) => string | ArrayBuffer;\n}\n\nconst createAxon = (\n    pos: Vector3,\n    dir: Vector3,\n    radius: number,\n    color: string | undefined,\n    gRatio: number,\n    {\n        deformation,\n        minDiameter,\n        ellipsoidSeparation,\n        voxelSize\n    }: {\n        deformation: Mapping;\n        minDiameter: Mapping;\n        ellipsoidSeparation: Mapping;\n        voxelSize: Vector3;\n    }\n): Axon => {\n    const axon: AxonState = {\n        start: projectOntoCube(pos, dir, voxelSize),\n        end: projectOntoCube(pos, dir.clone().negate(), voxelSize),\n        gRatio: gRatio || 1,\n        ellipsoidDensity: 1 / ellipsoidSeparation.map(radius * 2),\n        voxelSize,\n        deformation,\n        minDiameter,\n        color: color || randomHexColor(),\n        meshes: [],\n        radius: radius,\n        ellipsoids: [],\n        collisionTree: {\n            aabb: new Box3(new Vector3(0, 0, 0), new Vector3(0, 0, 0)),\n            containsPoint: () => false\n        }\n    };\n    axon.radius /= axon.gRatio;\n    axon.ellipsoids = [\n        createEllipsoid(axon.start, axon.radius, deformation, minDiameter, 1, axon.color, false),\n        createEllipsoid(axon.end, axon.radius, deformation, minDiameter, 1, axon.color, false)\n    ];\n    const dispose = () => {\n        axon.ellipsoids.forEach(e => e.dispose());\n        axon.meshes.forEach(mesh => {\n            mesh.geometry.dispose();\n            [mesh.material].flat().map(m => m.dispose());\n        });\n    };\n    const keepInVoxel = (minDist: number) => {\n        const a = axon.ellipsoids[0];\n        const b = axon.ellipsoids[axon.ellipsoids.length - 1];\n        axon.ellipsoids.slice(1, axon.ellipsoids.length - 1).forEach(ellipsoid => {\n            ellipsoid.keepInVoxel(axon.voxelSize, minDist);\n        });\n        [a, b].forEach(ellipsoid => {\n            const min = Math.min(\n                ...ellipsoid.pos.toArray().map((v, i) => axon.voxelSize.getComponent(i) / 2 - Math.abs(v))\n            );\n            ellipsoid.pos.fromArray(\n                ellipsoid.pos\n                    .toArray()\n                    .map((v, i) =>\n                        axon.voxelSize.getComponent(i) / 2 - Math.abs(v) === min\n                            ? (v = Math.sign(v) * (axon.voxelSize.getComponent(i) / 2))\n                            : v\n                    )\n            );\n        });\n    };\n    const getMinAndMaxDiameter = () => {\n        const d = axon.ellipsoids.map((e, i) =>\n            e.crossSectionDiameter(\n                axon.ellipsoids[Math.min(i + 1, axon.ellipsoids.length - 1)].pos\n                    .clone()\n                    .sub(axon.ellipsoids[Math.max(i - 1, 0)].pos)\n            )\n        );\n        return { min: Math.min(...d), max: Math.max(...d) };\n    };\n    const grow = (amount: number) => {\n        axon.ellipsoids.forEach(ellipsoid => ellipsoid.grow(amount));\n    };\n    const redistribute = () => {\n        const length = getLength();\n        const ellipsoidCount = 1 + Math.max(Math.ceil(length * axon.ellipsoidDensity), 1);\n        const dLength = length / (ellipsoidCount - 1);\n        let d = 0;\n        let index = 0;\n        axon.ellipsoids = [...Array(ellipsoidCount)].map(() => {\n            while (index + 2 < axon.ellipsoids.length) {\n                const l = axon.ellipsoids[index].pos\n                    .clone()\n                    .sub(axon.ellipsoids[index + 1].pos)\n                    .length();\n                if (d < l) break;\n                d -= l;\n                ++index;\n            }\n            const w =\n                d /\n                axon.ellipsoids[index].pos\n                    .clone()\n                    .sub(axon.ellipsoids[index + 1].pos)\n                    .length();\n            const e = createEllipsoid(\n                axon.ellipsoids[index].pos\n                    .clone()\n                    .multiplyScalar(1 - w)\n                    .add(axon.ellipsoids[index + 1].pos.clone().multiplyScalar(w)),\n                axon.radius,\n                axon.deformation,\n                axon.minDiameter,\n                1,\n                axon.color,\n                false\n            );\n            e.shape = addMatrix3(\n                axon.ellipsoids[index].shape.clone().multiplyScalar(1 - w),\n                axon.ellipsoids[index + 1].shape.clone().multiplyScalar(w)\n            );\n            d += dLength;\n            return e;\n        });\n    };\n    const contract = (amount: number) => {\n        for (let i = 1; i + 1 < axon.ellipsoids.length; ++i) {\n            const c = axon.ellipsoids[i + 1].pos\n                .clone()\n                .add(axon.ellipsoids[i - 1].pos)\n                .divideScalar(2);\n            const d = axon.ellipsoids[i + 1].pos.clone().sub(axon.ellipsoids[i - 1].pos);\n            d.normalize();\n            c.sub(axon.ellipsoids[i].pos);\n            d.multiplyScalar(c.dot(d));\n            c.sub(d);\n            axon.ellipsoids[i].pos.add(c.multiplyScalar(amount));\n        }\n        redistribute();\n    };\n    const getLength = () => {\n        let result = 0;\n        for (let i = 0; i + 1 < axon.ellipsoids.length; ++i)\n            result += axon.ellipsoids[i].pos\n                .clone()\n                .sub(axon.ellipsoids[i + 1].pos)\n                .length();\n        return result;\n    };\n    const getSurfacePoint = (pos: Vector3, dir: Vector3) => {\n        return axon.ellipsoids.reduce((pMax: Vector3 | undefined, ellipsoid: Ellipsoid) => {\n            const p = ellipsoid.getSurfacePoint(pos, dir);\n            if (!pMax) return p;\n            const distMax = pMax.clone().sub(pos).dot(dir);\n            if (!p) return pMax;\n            const dist = p.clone().sub(pos).dot(dir);\n            return dist > distMax ? p : pMax;\n        }, undefined);\n    };\n    const generatePipe = (\n        gRatio: number,\n        resolution: number,\n        extended: boolean,\n        viewSizes: boolean,\n        minAndMaxDiameter: { min: number; max: number }\n    ) => {\n        if (!extended)\n            return generatePipeUtil(axon.ellipsoids, axon.color, gRatio, resolution, viewSizes, minAndMaxDiameter);\n        const firstPos = axon.ellipsoids[0].pos;\n        const lastPos = axon.ellipsoids[axon.ellipsoids.length - 1].pos;\n        const d = lastPos.clone().sub(firstPos).normalize();\n        const n = new Vector3(1, 0, 0).cross(d).normalize();\n        const ellipsoids = [];\n        for (let i = axon.ellipsoids.length - 1; i > 1; --i) {\n            const e = axon.ellipsoids[i].clone();\n            e.pos.sub(firstPos).applyAxisAngle(n, Math.PI).add(firstPos);\n            ellipsoids.push(e);\n        }\n        for (let i = 0; i < axon.ellipsoids.length; ++i) {\n            const e = axon.ellipsoids[i].clone();\n            ellipsoids.push(e);\n        }\n        for (let i = axon.ellipsoids.length - 1; i > 1; --i) {\n            const e = axon.ellipsoids[i].clone();\n            e.pos.sub(lastPos).applyAxisAngle(n, Math.PI).add(lastPos);\n            ellipsoids.push(e);\n        }\n        return generatePipeUtil(ellipsoids, axon.color, gRatio, resolution, viewSizes, minAndMaxDiameter);\n    };\n    const generatePipes = (\n        scene: Scene,\n        resolution: number,\n        extended: boolean,\n        viewSizes: boolean,\n        minAndMaxDiameter: { min: number; max: number }\n    ) => {\n        const outer = generatePipe(1, resolution, extended, viewSizes, minAndMaxDiameter);\n        const inner = generatePipe(axon.gRatio, resolution, extended, viewSizes, minAndMaxDiameter);\n        scene.add(outer);\n        scene.add(inner);\n        axon.meshes.forEach(mesh => {\n            mesh.geometry.dispose();\n            [mesh.material].flat().map(m => m.dispose());\n        });\n        axon.meshes = [outer, inner];\n    };\n    const generateSkeleton = (scene: Scene, viewSizes: boolean, minAndMaxDiameter: { min: number; max: number }) => {\n        let geometry = new BufferGeometry().setFromPoints(axon.ellipsoids.map(ellipsoid => ellipsoid.pos));\n        if (viewSizes) {\n            const colors = axon.ellipsoids\n                .map((e, i) =>\n                    valueToColor(\n                        e.crossSectionDiameter(\n                            axon.ellipsoids[Math.min(i + 1, axon.ellipsoids.length - 1)].pos\n                                .clone()\n                                .sub(axon.ellipsoids[Math.max(i - 1, 0)].pos)\n                        ) * axon.gRatio,\n                        minAndMaxDiameter\n                    ).toArray()\n                )\n                .flat();\n            geometry.setAttribute(\"color\", new BufferAttribute(new Float32Array(colors), 3));\n        } else geometry = applyColor(geometry, axon.color);\n        const mesh = new Line(geometry, new LineBasicMaterial({ vertexColors: true, side: DoubleSide }));\n        axon.meshes.forEach(mesh => {\n            mesh.geometry.dispose();\n            [mesh.material].flat().map(m => m.dispose());\n        });\n        axon.meshes = [mesh];\n        scene.add(mesh);\n    };\n    const draw = (scene: Scene, viewSizes: boolean, minAndMaxDiameter: { min: number; max: number }) => {\n        if (viewSizes) return axon.ellipsoids.map(e => e.draw(scene, true, minAndMaxDiameter));\n        const geom = applyColor(new SphereBufferGeometry(1, 16, 16), axon.color);\n        const material = new MeshPhongMaterial({ vertexColors: true, side: DoubleSide });\n        const mesh = new InstancedMesh(geom, material, axon.ellipsoids.length);\n        axon.ellipsoids.forEach((ellipsoid, i) => {\n            mesh.setMatrixAt(i, ellipsoid.getMatrix4());\n        });\n        scene.add(mesh);\n        axon.meshes = [mesh];\n    };\n    const toJSON = () => {\n        return {\n            position: [axon.start.x, axon.start.y, axon.start.z],\n            direction: [axon.end.x - axon.start.x, axon.end.y - axon.start.y, axon.end.z - axon.start.z],\n            maxDiameter: axon.radius * axon.gRatio * 2,\n            color: axon.color,\n            gRatio: axon.gRatio,\n            ellipsoids: axon.ellipsoids.map((ellipsoid, i) => {\n                const myelinDiameter = ellipsoid.crossSectionDiameter(\n                    axon.ellipsoids[Math.min(i + 1, axon.ellipsoids.length - 1)].pos\n                        .clone()\n                        .sub(axon.ellipsoids[Math.max(i - 1, 0)].pos)\n                );\n                return {\n                    position: [ellipsoid.pos.x, ellipsoid.pos.y, ellipsoid.pos.z],\n                    shape: ellipsoid.shape.elements,\n                    axonDiameter: myelinDiameter * axon.gRatio,\n                    myelinDiameter: myelinDiameter\n                };\n            })\n        };\n    };\n    const toPLY = (binary: boolean, simple: boolean, i: number) => {\n        const geometry = axon.meshes[i].geometry;\n        const geom = geometry instanceof Geometry ? new BufferGeometry().fromGeometry(geometry) : geometry;\n        return plyParser([geom], {\n            binary: binary,\n            includeColors: !simple,\n            includeNormals: !simple,\n            littleEndian: false\n        });\n    };\n    redistribute();\n    return Object.assign(axon, {\n        dispose,\n        keepInVoxel,\n        computeCollisionTree: (minDist: number) => {\n            axon.collisionTree = computeCollisionTree(axon.ellipsoids, minDist);\n        },\n        collision: (ax: Axon, minDist: number, maxOverlap: number) =>\n            collision(axon.collisionTree, ax.collisionTree, minDist, maxOverlap),\n        getOverlap: (ax: Axon, minDist: number, maxOverlap: number) =>\n            getOverlap(axon.collisionTree, ax.collisionTree, minDist, maxOverlap),\n        getMinAndMaxDiameter,\n        grow,\n        contract,\n        redistribute,\n        getLength,\n        getSurfacePoint,\n        generatePipe,\n        generatePipes,\n        generateSkeleton,\n        draw,\n        toJSON,\n        toPLY\n    });\n};\n\nexport default createAxon;\n","type Vec2 = {\n    x: number;\n    y: number;\n};\n\nexport type MappingJSON = {\n    from: number[];\n    to: number[];\n};\n\nexport type Mapping = {\n    values: Vec2[];\n    valuesInverse: Vec2[];\n    map: (x: number) => number;\n    mapInverse: (x: number) => number;\n    toJSON: () => MappingJSON;\n};\n\nconst map1 = (x: number, v1: Vec2, v2: Vec2) => v1.y + ((v2.y - v1.y) * (x - v1.x)) / (v2.x - v1.x);\n\nconst map2 = (values: Vec2[], x: number, i: number, j: number): number => {\n    if (i === j) return values[i].y;\n    if (i + 1 === j) return map1(x, values[i], values[j]);\n    const k = (i + j) / 2;\n    if (x < values[k].x) return map2(values, x, i, k);\n    return map2(values, x, k, j);\n};\n\nconst map3 = (values: Vec2[], x: number) => map2(values, x, 0, values.length - 1);\n\nconst createMapping = ({ from, to }: { from: number[]; to: number[] }) => {\n    const values = from.map((xv, i) => ({\n        x: xv,\n        y: to[i]\n    }));\n    const valuesInverse = values.map(value => ({ x: value.y, y: value.x }));\n    const mapping: Mapping = {\n        values,\n        valuesInverse,\n        map: x => map3(values, x),\n        mapInverse: y => map3(valuesInverse, y),\n        toJSON: () => ({ from: values.map(v => v.x), to: values.map(v => v.y) })\n    };\n    return mapping;\n};\n\nexport default createMapping;\n","/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nimport {\n    BufferAttribute,\n    BufferGeometry,\n    InterleavedBuffer,\n    InterleavedBufferAttribute,\n    TriangleFanDrawMode,\n    TriangleStripDrawMode,\n    TrianglesDrawMode,\n    Vector2,\n    Vector3\n} from \"three\";\n\nlet BufferGeometryUtils = {\n    computeTangents: function (geometry) {\n        let index = geometry.index;\n        let attributes = geometry.attributes;\n\n        // based on http://www.terathon.com/code/tangent.html\n        // (per vertex tangents)\n\n        if (\n            index === null ||\n            attributes.position === undefined ||\n            attributes.normal === undefined ||\n            attributes.uv === undefined\n        ) {\n            console.error(\n                \"THREE.BufferGeometryUtils: .computeTangents() failed. Missing required attributes (index, position, normal or uv)\"\n            );\n            return;\n        }\n\n        let indices = index.array;\n        let positions = attributes.position.array;\n        let normals = attributes.normal.array;\n        let uvs = attributes.uv.array;\n\n        let nVertices = positions.length / 3;\n\n        if (attributes.tangent === undefined) {\n            geometry.setAttribute(\"tangent\", new BufferAttribute(new Float32Array(4 * nVertices), 4));\n        }\n\n        let tangents = attributes.tangent.array;\n\n        let tan1 = [],\n            tan2 = [];\n\n        for (let i = 0; i < nVertices; i++) {\n            tan1[i] = new Vector3();\n            tan2[i] = new Vector3();\n        }\n\n        let vA = new Vector3(),\n            vB = new Vector3(),\n            vC = new Vector3(),\n            uvA = new Vector2(),\n            uvB = new Vector2(),\n            uvC = new Vector2(),\n            sdir = new Vector3(),\n            tdir = new Vector3();\n\n        function handleTriangle(a, b, c) {\n            vA.fromArray(positions, a * 3);\n            vB.fromArray(positions, b * 3);\n            vC.fromArray(positions, c * 3);\n\n            uvA.fromArray(uvs, a * 2);\n            uvB.fromArray(uvs, b * 2);\n            uvC.fromArray(uvs, c * 2);\n\n            vB.sub(vA);\n            vC.sub(vA);\n\n            uvB.sub(uvA);\n            uvC.sub(uvA);\n\n            let r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);\n\n            // silently ignore degenerate uv triangles having coincident or colinear vertices\n\n            if (!isFinite(r)) return;\n\n            sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n            tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n\n            tan1[a].add(sdir);\n            tan1[b].add(sdir);\n            tan1[c].add(sdir);\n\n            tan2[a].add(tdir);\n            tan2[b].add(tdir);\n            tan2[c].add(tdir);\n        }\n\n        let groups = geometry.groups;\n\n        if (groups.length === 0) {\n            groups = [\n                {\n                    start: 0,\n                    count: indices.length\n                }\n            ];\n        }\n\n        for (let i = 0, il = groups.length; i < il; ++i) {\n            let group = groups[i];\n\n            let start = group.start;\n            let count = group.count;\n\n            for (let j = start, jl = start + count; j < jl; j += 3) {\n                handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);\n            }\n        }\n\n        let tmp = new Vector3(),\n            tmp2 = new Vector3();\n        let n = new Vector3(),\n            n2 = new Vector3();\n        let w, t, test;\n\n        function handleVertex(v) {\n            n.fromArray(normals, v * 3);\n            n2.copy(n);\n\n            t = tan1[v];\n\n            // Gram-Schmidt orthogonalize\n\n            tmp.copy(t);\n            tmp.sub(n.multiplyScalar(n.dot(t))).normalize();\n\n            // Calculate handedness\n\n            tmp2.crossVectors(n2, t);\n            test = tmp2.dot(tan2[v]);\n            w = test < 0.0 ? -1.0 : 1.0;\n\n            tangents[v * 4] = tmp.x;\n            tangents[v * 4 + 1] = tmp.y;\n            tangents[v * 4 + 2] = tmp.z;\n            tangents[v * 4 + 3] = w;\n        }\n\n        for (let i = 0, il = groups.length; i < il; ++i) {\n            let group = groups[i];\n\n            let start = group.start;\n            let count = group.count;\n\n            for (let j = start, jl = start + count; j < jl; j += 3) {\n                handleVertex(indices[j + 0]);\n                handleVertex(indices[j + 1]);\n                handleVertex(indices[j + 2]);\n            }\n        }\n    },\n\n    /**\n     * @param  {Array<BufferGeometry>} geometries\n     * @param  {Boolean} useGroups\n     * @return {BufferGeometry}\n     */\n    mergeBufferGeometries: function (geometries, useGroups) {\n        let isIndexed = geometries[0].index !== null;\n\n        let attributesUsed = new Set(Object.keys(geometries[0].attributes));\n        let morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n\n        let attributes = {};\n        let morphAttributes = {};\n\n        let morphTargetsRelative = geometries[0].morphTargetsRelative;\n\n        let mergedGeometry = new BufferGeometry();\n\n        let offset = 0;\n\n        for (let i = 0; i < geometries.length; ++i) {\n            let geometry = geometries[i];\n            let attributesCount = 0;\n\n            // ensure that all geometries are indexed, or none\n\n            if (isIndexed !== (geometry.index !== null)) {\n                console.error(\n                    \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" +\n                        i +\n                        \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\"\n                );\n                return null;\n            }\n\n            // gather attributes, exit early if they're different\n\n            for (let name in geometry.attributes) {\n                if (!attributesUsed.has(name)) {\n                    console.error(\n                        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" +\n                            i +\n                            '. All geometries must have compatible attributes; make sure \"' +\n                            name +\n                            '\" attribute exists among all geometries, or in none of them.'\n                    );\n                    return null;\n                }\n\n                if (attributes[name] === undefined) attributes[name] = [];\n\n                attributes[name].push(geometry.attributes[name]);\n\n                attributesCount++;\n            }\n\n            // ensure geometries have the same number of attributes\n\n            if (attributesCount !== attributesUsed.size) {\n                console.error(\n                    \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" +\n                        i +\n                        \". Make sure all geometries have the same number of attributes.\"\n                );\n                return null;\n            }\n\n            // gather morph attributes, exit early if they're different\n\n            if (morphTargetsRelative !== geometry.morphTargetsRelative) {\n                console.error(\n                    \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" +\n                        i +\n                        \". .morphTargetsRelative must be consistent throughout all geometries.\"\n                );\n                return null;\n            }\n\n            for (let name in geometry.morphAttributes) {\n                if (!morphAttributesUsed.has(name)) {\n                    console.error(\n                        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" +\n                            i +\n                            \".  .morphAttributes must be consistent throughout all geometries.\"\n                    );\n                    return null;\n                }\n\n                if (morphAttributes[name] === undefined) morphAttributes[name] = [];\n\n                morphAttributes[name].push(geometry.morphAttributes[name]);\n            }\n\n            // gather .userData\n\n            mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n            mergedGeometry.userData.mergedUserData.push(geometry.userData);\n\n            if (useGroups) {\n                let count;\n\n                if (isIndexed) {\n                    count = geometry.index.count;\n                } else if (geometry.attributes.position !== undefined) {\n                    count = geometry.attributes.position.count;\n                } else {\n                    console.error(\n                        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" +\n                            i +\n                            \". The geometry must have either an index or a position attribute\"\n                    );\n                    return null;\n                }\n\n                mergedGeometry.addGroup(offset, count, i);\n\n                offset += count;\n            }\n        }\n\n        // merge indices\n\n        if (isIndexed) {\n            let indexOffset = 0;\n            let mergedIndex = [];\n\n            for (let i = 0; i < geometries.length; ++i) {\n                let index = geometries[i].index;\n\n                for (let j = 0; j < index.count; ++j) {\n                    mergedIndex.push(index.getX(j) + indexOffset);\n                }\n\n                indexOffset += geometries[i].attributes.position.count;\n            }\n\n            mergedGeometry.setIndex(mergedIndex);\n        }\n\n        // merge attributes\n\n        for (let name in attributes) {\n            let mergedAttribute = this.mergeBufferAttributes(attributes[name]);\n\n            if (!mergedAttribute) {\n                console.error(\n                    \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" +\n                        name +\n                        \" attribute.\"\n                );\n                return null;\n            }\n\n            mergedGeometry.setAttribute(name, mergedAttribute);\n        }\n\n        // merge morph attributes\n\n        for (let name in morphAttributes) {\n            let numMorphTargets = morphAttributes[name][0].length;\n\n            if (numMorphTargets === 0) break;\n\n            mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n            mergedGeometry.morphAttributes[name] = [];\n\n            for (let i = 0; i < numMorphTargets; ++i) {\n                let morphAttributesToMerge = [];\n\n                for (let j = 0; j < morphAttributes[name].length; ++j) {\n                    morphAttributesToMerge.push(morphAttributes[name][j][i]);\n                }\n\n                let mergedMorphAttribute = this.mergeBufferAttributes(morphAttributesToMerge);\n\n                if (!mergedMorphAttribute) {\n                    console.error(\n                        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" +\n                            name +\n                            \" morphAttribute.\"\n                    );\n                    return null;\n                }\n\n                mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n            }\n        }\n\n        return mergedGeometry;\n    },\n\n    /**\n     * @param {Array<BufferAttribute>} attributes\n     * @return {BufferAttribute}\n     */\n    mergeBufferAttributes: function (attributes) {\n        let TypedArray;\n        let itemSize;\n        let normalized;\n        let arrayLength = 0;\n\n        for (let i = 0; i < attributes.length; ++i) {\n            let attribute = attributes[i];\n\n            if (attribute.isInterleavedBufferAttribute) {\n                console.error(\n                    \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.\"\n                );\n                return null;\n            }\n\n            if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n            if (TypedArray !== attribute.array.constructor) {\n                console.error(\n                    \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\"\n                );\n                return null;\n            }\n\n            if (itemSize === undefined) itemSize = attribute.itemSize;\n            if (itemSize !== attribute.itemSize) {\n                console.error(\n                    \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\"\n                );\n                return null;\n            }\n\n            if (normalized === undefined) normalized = attribute.normalized;\n            if (normalized !== attribute.normalized) {\n                console.error(\n                    \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\"\n                );\n                return null;\n            }\n\n            arrayLength += attribute.array.length;\n        }\n\n        let array = new TypedArray(arrayLength);\n        let offset = 0;\n\n        for (let i = 0; i < attributes.length; ++i) {\n            array.set(attributes[i].array, offset);\n\n            offset += attributes[i].array.length;\n        }\n\n        return new BufferAttribute(array, itemSize, normalized);\n    },\n\n    /**\n     * @param {Array<BufferAttribute>} attributes\n     * @return {Array<InterleavedBufferAttribute>}\n     */\n    interleaveAttributes: function (attributes) {\n        // Interleaves the provided attributes into an InterleavedBuffer and returns\n        // a set of InterleavedBufferAttributes for each attribute\n        let TypedArray;\n        let arrayLength = 0;\n        let stride = 0;\n\n        // calculate the the length and type of the interleavedBuffer\n        for (let i = 0, l = attributes.length; i < l; ++i) {\n            let attribute = attributes[i];\n\n            if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n            if (TypedArray !== attribute.array.constructor) {\n                console.error(\"AttributeBuffers of different types cannot be interleaved\");\n                return null;\n            }\n\n            arrayLength += attribute.array.length;\n            stride += attribute.itemSize;\n        }\n\n        // Create the set of buffer attributes\n        let interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n        let offset = 0;\n        let res = [];\n        let getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n        let setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n\n        for (let j = 0, l = attributes.length; j < l; j++) {\n            let attribute = attributes[j];\n            let itemSize = attribute.itemSize;\n            let count = attribute.count;\n            let iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n            res.push(iba);\n\n            offset += itemSize;\n\n            // Move the data for each attribute into the new interleavedBuffer\n            // at the appropriate offset\n            for (let c = 0; c < count; c++) {\n                for (let k = 0; k < itemSize; k++) {\n                    iba[setters[k]](c, attribute[getters[k]](c));\n                }\n            }\n        }\n\n        return res;\n    },\n\n    /**\n     * @param {Array<BufferGeometry>} geometry\n     * @return {number}\n     */\n    estimateBytesUsed: function (geometry) {\n        // Return the estimated memory used by this geometry in bytes\n        // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n        // for InterleavedBufferAttributes.\n        let mem = 0;\n        for (let name in geometry.attributes) {\n            let attr = geometry.getAttribute(name);\n            mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n        }\n\n        let indices = geometry.getIndex();\n        mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n        return mem;\n    },\n\n    /**\n     * @param {BufferGeometry} geometry\n     * @param {number} tolerance\n     * @return {BufferGeometry>}\n     */\n    mergeVertices: function (geometry, tolerance = 1e-4) {\n        tolerance = Math.max(tolerance, Number.EPSILON);\n\n        // Generate an index buffer if the geometry doesn't have one, or optimize it\n        // if it's already available.\n        let hashToIndex = {};\n        let indices = geometry.getIndex();\n        let positions = geometry.getAttribute(\"position\");\n        let vertexCount = indices ? indices.count : positions.count;\n\n        // next value for triangle indices\n        let nextIndex = 0;\n\n        // attributes and new attribute arrays\n        let attributeNames = Object.keys(geometry.attributes);\n        let attrArrays = {};\n        let morphAttrsArrays = {};\n        let newIndices = [];\n        let getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n\n        // initialize the arrays\n        for (let i = 0, l = attributeNames.length; i < l; i++) {\n            let name = attributeNames[i];\n\n            attrArrays[name] = [];\n\n            let morphAttr = geometry.morphAttributes[name];\n            if (morphAttr) {\n                morphAttrsArrays[name] = new Array(morphAttr.length).fill().map(() => []);\n            }\n        }\n\n        // convert the error tolerance to an amount of decimal places to truncate to\n        let decimalShift = Math.log10(1 / tolerance);\n        let shiftMultiplier = Math.pow(10, decimalShift);\n        for (let i = 0; i < vertexCount; i++) {\n            let index = indices ? indices.getX(i) : i;\n\n            // Generate a hash for the vertex attributes at the current index 'i'\n            let hash = \"\";\n            for (let j = 0, l = attributeNames.length; j < l; j++) {\n                let name = attributeNames[j];\n                let attribute = geometry.getAttribute(name);\n                let itemSize = attribute.itemSize;\n\n                for (let k = 0; k < itemSize; k++) {\n                    // double tilde truncates the decimal value\n                    hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n                }\n            }\n\n            // Add another reference to the vertex if it's already\n            // used by another index\n            if (hash in hashToIndex) {\n                newIndices.push(hashToIndex[hash]);\n            } else {\n                // copy data to the new index in the attribute arrays\n                for (let j = 0, l = attributeNames.length; j < l; j++) {\n                    let name = attributeNames[j];\n                    let attribute = geometry.getAttribute(name);\n                    let morphAttr = geometry.morphAttributes[name];\n                    let itemSize = attribute.itemSize;\n                    let newarray = attrArrays[name];\n                    let newMorphArrays = morphAttrsArrays[name];\n\n                    for (let k = 0; k < itemSize; k++) {\n                        let getterFunc = getters[k];\n                        newarray.push(attribute[getterFunc](index));\n\n                        if (morphAttr) {\n                            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n                                newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n                            }\n                        }\n                    }\n                }\n\n                hashToIndex[hash] = nextIndex;\n                newIndices.push(nextIndex);\n                nextIndex++;\n            }\n        }\n\n        // Generate typed arrays from new attribute arrays and update\n        // the attributeBuffers\n        const result = geometry.clone();\n        for (let i = 0, l = attributeNames.length; i < l; i++) {\n            let name = attributeNames[i];\n            let oldAttribute = geometry.getAttribute(name);\n\n            let buffer = new oldAttribute.array.constructor(attrArrays[name]);\n            let attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n\n            result.setAttribute(name, attribute);\n\n            // Update the attribute arrays\n            if (name in morphAttrsArrays) {\n                for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n                    let oldMorphAttribute = geometry.morphAttributes[name][j];\n\n                    let buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n                    let morphAttribute = new BufferAttribute(\n                        buffer,\n                        oldMorphAttribute.itemSize,\n                        oldMorphAttribute.normalized\n                    );\n                    result.morphAttributes[name][j] = morphAttribute;\n                }\n            }\n        }\n\n        // indices\n\n        result.setIndex(newIndices);\n\n        return result;\n    },\n\n    /**\n     * @param {BufferGeometry} geometry\n     * @param {number} drawMode\n     * @return {BufferGeometry>}\n     */\n    toTrianglesDrawMode: function (geometry, drawMode) {\n        if (drawMode === TrianglesDrawMode) {\n            console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n            return geometry;\n        }\n\n        if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n            let index = geometry.getIndex();\n\n            // generate index if not present\n\n            if (index === null) {\n                let indices = [];\n\n                let position = geometry.getAttribute(\"position\");\n\n                if (position !== undefined) {\n                    for (let i = 0; i < position.count; i++) {\n                        indices.push(i);\n                    }\n\n                    geometry.setIndex(indices);\n                    index = geometry.getIndex();\n                } else {\n                    console.error(\n                        \"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"\n                    );\n                    return geometry;\n                }\n            }\n\n            //\n\n            let numberOfTriangles = index.count - 2;\n            let newIndices = [];\n\n            if (drawMode === TriangleFanDrawMode) {\n                // gl.TRIANGLE_FAN\n\n                for (let i = 1; i <= numberOfTriangles; i++) {\n                    newIndices.push(index.getX(0));\n                    newIndices.push(index.getX(i));\n                    newIndices.push(index.getX(i + 1));\n                }\n            } else {\n                // gl.TRIANGLE_STRIP\n\n                for (let i = 0; i < numberOfTriangles; i++) {\n                    if (i % 2 === 0) {\n                        newIndices.push(index.getX(i));\n                        newIndices.push(index.getX(i + 1));\n                        newIndices.push(index.getX(i + 2));\n                    } else {\n                        newIndices.push(index.getX(i + 2));\n                        newIndices.push(index.getX(i + 1));\n                        newIndices.push(index.getX(i));\n                    }\n                }\n            }\n\n            if (newIndices.length / 3 !== numberOfTriangles) {\n                console.error(\n                    \"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\"\n                );\n            }\n\n            // build final geometry\n\n            let newGeometry = geometry.clone();\n            newGeometry.setIndex(newIndices);\n            newGeometry.clearGroups();\n\n            return newGeometry;\n        } else {\n            console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n            return geometry;\n        }\n    }\n};\n\nexport { BufferGeometryUtils };\n","import {\n    Vector3,\n    Matrix3,\n    LineSegments,\n    BoxGeometry,\n    EdgesGeometry,\n    LineBasicMaterial,\n    Scene,\n    AmbientLight,\n    DirectionalLight,\n    MeshPhongMaterial,\n    MeshToonMaterial,\n    Color,\n    DoubleSide,\n    Geometry,\n    BufferGeometry\n} from \"three\";\nimport { addMatrix3, randomPosition, shuffle } from \"./helperFunctions\";\nimport random from \"./random\";\nimport createAxon, { Axon, AxonJSON } from \"./axon\";\nimport { BufferGeometryUtils } from \"./BufferGeometryUtils\";\nimport createEllipsoid, { Ellipsoid, CellJSON } from \"./ellipsoid\";\nimport createMapping, { Mapping, MappingJSON } from \"./mapping\";\nimport plyParser from \"./plyParser\";\n\nconst wireframeCube = (size: Vector3) =>\n    new LineSegments(\n        new EdgesGeometry(new BoxGeometry(size.x, size.y, size.z)),\n        new LineBasicMaterial({ color: 0xffffff, linewidth: 2 })\n    );\n\nexport type SynthesizerJSON = {\n    voxelSize: number[];\n    mapFromDiameterToDeformationFactor: MappingJSON;\n    mapFromMaxDiameterToMinDiameter: MappingJSON;\n    mapFromMaxDiameterToEllipsoidSeparation: MappingJSON;\n    axons: AxonJSON[];\n    cells: CellJSON[];\n};\n\ntype UpdateState = {\n    name: string;\n    progress: number;\n    volumeFraction?: [number, number];\n};\n\ntype Focus = {\n    type: string;\n    object: Axon | Ellipsoid | null;\n};\n\nconst isAxon = (type: string, object: Axon | Ellipsoid | null): object is Axon => type === \"axon\";\n\ninterface SynthesizerState {\n    voxelSize: Vector3;\n    deformation: Mapping;\n    minDiameter: Mapping;\n    ellipsoidSeparation: Mapping;\n    axons: Axon[];\n    cells: Ellipsoid[];\n    updateState: UpdateState;\n    focus: Focus;\n    minAndMaxDiameterAxons: { min: number; max: number };\n    minAndMaxDiameterCells: { min: number; max: number };\n}\n\nexport interface Synthesizer extends SynthesizerState {\n    dispose: () => void;\n    toJSON: () => SynthesizerJSON;\n    toPLY: (binary: boolean, simple: boolean) => string | ArrayBuffer;\n    keepInVoxel: (minDist: number) => void;\n    collision: (minDist: number, maxOverlap: number) => void;\n    getOverlap: (minDist: number, maxOverlap: number) => number;\n    addAxonsRandomly: (axonCount: number, gRatio: number) => void;\n    addCellsRandomly: (cellCount: number, minDist: number) => void;\n    volumeFraction: (n: number, border: number) => [number, number];\n    update: (growSpeed: number, contractSpeed: number, minDist: number, maxOverlap: number, border: number) => void;\n    generatePipes: (scene: Scene, resolution: number, extended: boolean, viewSizes: boolean) => Scene;\n    drawLight: (scene: Scene) => void;\n    drawVoxels: (scene: Scene, mode: string, border: number) => void;\n    drawAxons: (scene: Scene, mode: string, viewSizes: boolean, resolution: number, extended: boolean) => void;\n    drawCells: (scene: Scene, mode: string) => void;\n    computeMinAndMaxDiameter: () => void;\n    draw: (\n        voxelMode: string,\n        axonMode: string,\n        cellMode: string,\n        resolution: number,\n        extended: boolean,\n        border: number,\n        viewSizes: boolean\n    ) => Scene;\n    point: (camPos: Vector3, cursorDir: Vector3) => Focus;\n    deselectAll: () => void;\n}\n\nconst createSynthesizer = (config: SynthesizerJSON): Synthesizer => {\n    const synthesizer: SynthesizerState = {\n        voxelSize:\n            typeof config.voxelSize === \"number\"\n                ? new Vector3(config.voxelSize, config.voxelSize, config.voxelSize)\n                : new Vector3().fromArray(config.voxelSize),\n        deformation: createMapping(config.mapFromDiameterToDeformationFactor),\n        minDiameter: createMapping(config.mapFromMaxDiameterToMinDiameter),\n        ellipsoidSeparation: createMapping(config.mapFromMaxDiameterToEllipsoidSeparation),\n        axons: [],\n        cells: [],\n        updateState: {\n            name: \"ready\",\n            progress: 0\n        },\n        focus: {\n            type: \"\",\n            object: null\n        },\n        minAndMaxDiameterAxons: { min: 0, max: 0 },\n        minAndMaxDiameterCells: { min: 0, max: 0 }\n    };\n    (config.axons || []).forEach(axon => {\n        synthesizer.axons.push(\n            createAxon(\n                new Vector3(...axon.position),\n                new Vector3(...axon.direction),\n                axon.maxDiameter / 2,\n                axon.color,\n                axon.gRatio,\n                synthesizer\n            )\n        );\n        const a = synthesizer.axons[synthesizer.axons.length - 1];\n        if (!axon.ellipsoids) return;\n        a.ellipsoids.forEach((e, i) => {\n            const t = (axon.ellipsoids.length - 1) * (i / (a.ellipsoids.length - 1));\n            const index = Math.min(Math.floor(t), axon.ellipsoids.length - 2);\n            const w = t - index;\n            e.pos = new Vector3(...axon.ellipsoids[index].position)\n                .clone()\n                .multiplyScalar(1 - w)\n                .add(new Vector3(...axon.ellipsoids[index + 1].position).clone().multiplyScalar(w));\n            e.shape = addMatrix3(\n                new Matrix3()\n                    .fromArray(axon.ellipsoids[index].shape)\n                    .clone()\n                    .multiplyScalar(1 - w),\n                new Matrix3()\n                    .fromArray(axon.ellipsoids[index + 1].shape)\n                    .clone()\n                    .multiplyScalar(w)\n            );\n        });\n    });\n\n    const computeMinAndMaxDiameter = () => {\n        const dAxons = synthesizer.axons.map(a => a.getMinAndMaxDiameter());\n        const dCells = synthesizer.cells.map(c => c.diameter());\n        synthesizer.minAndMaxDiameterAxons = {\n            min: Math.min(...dAxons.map(d => d.min)),\n            max: Math.max(...dAxons.map(d => d.max))\n        };\n        synthesizer.minAndMaxDiameterCells = {\n            min: Math.min(...dCells),\n            max: Math.max(...dCells)\n        };\n    };\n\n    (config.cells || []).forEach(c => {\n        const shape = new Matrix3().fromArray(c.shape);\n        const cell = createEllipsoid(\n            new Vector3(...c.position),\n            Math.cbrt(shape.determinant()),\n            createMapping({ from: [0], to: [0] }),\n            createMapping({ from: [0], to: [0] }),\n            0,\n            c.color,\n            true\n        );\n        cell.shape = shape.clone();\n        synthesizer.cells.push(cell);\n    });\n    computeMinAndMaxDiameter();\n\n    const dispose = () => {\n        synthesizer.axons.forEach(axon => axon.dispose());\n        synthesizer.cells.forEach(cell => cell.dispose());\n    };\n    const toJSON = () => {\n        return {\n            voxelSize: synthesizer.voxelSize.toArray(),\n            mapFromDiameterToDeformationFactor: synthesizer.deformation.toJSON(),\n            mapFromMaxDiameterToMinDiameter: synthesizer.minDiameter.toJSON(),\n            mapFromMaxDiameterToEllipsoidSeparation: synthesizer.ellipsoidSeparation.toJSON(),\n            axons: synthesizer.axons.map(axon => axon.toJSON()),\n            cells: synthesizer.cells.map(cell => ({\n                position: cell.pos.toArray(),\n                shape: cell.shape.elements,\n                color: cell.color\n            }))\n        };\n    };\n    const toPLY = (binary: boolean, simple: boolean) => {\n        return plyParser(\n            [\n                synthesizer.axons.map(a =>\n                    a.meshes.filter((_, i) => i !== 1 || Number(a.gRatio) !== 1).map(mesh => mesh.geometry)\n                ),\n                synthesizer.cells.map(c => c.mesh?.geometry || new BufferGeometry())\n            ]\n                .flat()\n                .flat()\n                .map(geom => (geom instanceof Geometry ? new BufferGeometry().fromGeometry(geom) : geom))\n                .map(geom => BufferGeometryUtils.mergeVertices(geom)),\n            {\n                binary: binary,\n                includeColors: !simple,\n                includeNormals: !simple,\n                littleEndian: false\n            }\n        );\n    };\n    const keepInVoxel = (minDist: number) => {\n        synthesizer.axons.forEach(axon => axon.keepInVoxel(minDist));\n    };\n    const collision = (minDist: number, maxOverlap: number) => {\n        synthesizer.axons.forEach(a => a.computeCollisionTree(minDist));\n        const pairs: Axon[][] = [];\n        synthesizer.axons.forEach((a, i) => {\n            synthesizer.axons.forEach((b, j) => {\n                if (i < j) pairs.push(shuffle([a, b]));\n            });\n        });\n        shuffle(pairs);\n        pairs.forEach(pair => pair[0].collision(pair[1], minDist, maxOverlap));\n        synthesizer.axons.forEach(a =>\n            a.ellipsoids.forEach(ellipsoid =>\n                synthesizer.cells.forEach(c => ellipsoid.collision(c, minDist, maxOverlap))\n            )\n        );\n    };\n    const getOverlap = (minDist: number, maxOverlap: number) => {\n        let result = maxOverlap;\n        synthesizer.axons.forEach(a => a.computeCollisionTree(minDist));\n        synthesizer.axons.forEach((a, i) => {\n            synthesizer.axons.forEach((b, j) => {\n                if (i >= j) return;\n                result = Math.max(result, a.getOverlap(b, minDist, result));\n            });\n        });\n        return result;\n    };\n    const addAxonsRandomly = (axonCount: number, gRatio: number) => {\n        for (let i = 0; i < axonCount; ++i)\n            synthesizer.axons.push(\n                createAxon(\n                    randomPosition().multiply(synthesizer.voxelSize),\n                    randomPosition(),\n                    0.1 + random() * 10,\n                    undefined,\n                    gRatio,\n                    synthesizer\n                )\n            );\n        computeMinAndMaxDiameter();\n        console.log(\"Total number of axons: \" + synthesizer.axons.length);\n    };\n    const addCellsRandomly = (cellCount: number, minDist: number) => {\n        for (let i = 0; i < cellCount; ++i) {\n            const p = randomPosition().multiply(synthesizer.voxelSize);\n            const r = 2.5 + random() * 7;\n            synthesizer.cells.push(\n                createEllipsoid(\n                    p,\n                    r,\n                    createMapping({ from: [0, 1], to: [0, 0] }),\n                    createMapping({ from: [0, 1], to: [0, 0.01] }),\n                    1,\n                    undefined,\n                    true\n                )\n            );\n        }\n        const maxOverlap = 0.0001;\n        synthesizer.cells.forEach(a => a.grow(1));\n        for (let mo = 1; mo > maxOverlap; ) {\n            synthesizer.cells.forEach((a, i) => {\n                synthesizer.cells.forEach((b, j) => {\n                    if (i >= j) return;\n                    a.collision(b, maxOverlap, maxOverlap);\n                });\n            });\n            mo = 0;\n            synthesizer.cells.forEach(c => c.keepInVoxel(synthesizer.voxelSize, minDist));\n            synthesizer.cells.forEach((a, i) => {\n                synthesizer.cells.forEach((b, j) => {\n                    if (i >= j) return;\n                    mo = Math.max(mo, a.getOverlap(b, 0, mo));\n                });\n            });\n            synthesizer.cells.forEach(a => a.grow(-0.05));\n        }\n        synthesizer.cells.forEach(a => {\n            a.deformation = createMapping({ from: [0], to: [0] });\n            a.movement = 0;\n        });\n        computeMinAndMaxDiameter();\n    };\n    const volumeFraction = (n: number, border: number): [number, number] => {\n        synthesizer.axons.forEach(axon => axon.computeCollisionTree(0));\n        let axonCount = 0;\n        let cellCount = 0;\n        for (let i = 0; i < n; ++i) {\n            for (let j = 0; j < n; ++j) {\n                for (let k = 0; k < n; ++k) {\n                    const p = new Vector3(i + 0.5, j + 0.5, k + 0.5)\n                        .divideScalar(n)\n                        .sub(new Vector3(0.5, 0.5, 0.5))\n                        .multiply(new Vector3().fromArray(synthesizer.voxelSize.toArray().map(v => v - 2 * border)));\n                    let inside = false;\n                    synthesizer.axons.forEach(axon => {\n                        if (axon.collisionTree.containsPoint(p)) inside = true;\n                    });\n                    if (inside) ++axonCount;\n                    inside = false;\n                    synthesizer.cells.forEach(cell => {\n                        if (cell.containsPoint(p)) inside = true;\n                    });\n                    if (inside) ++cellCount;\n                }\n            }\n        }\n        return [axonCount / (n * n * n), cellCount / (n * n * n)];\n    };\n    const update = (growSpeed: number, contractSpeed: number, minDist: number, maxOverlap: number, border: number) => {\n        switch (synthesizer.updateState.name) {\n            case \"ready\":\n                synthesizer.updateState = { name: \"grow\", progress: 0 };\n                break;\n            case \"grow\":\n                synthesizer.axons.forEach(axon => axon.grow(growSpeed));\n                synthesizer.updateState = { name: \"contract\", progress: 0 };\n                break;\n            case \"contract\":\n                for (let i = 0; i < contractSpeed; ++i)\n                    synthesizer.axons.forEach(axon => axon.contract(Math.min(contractSpeed - i, 1)));\n                synthesizer.updateState = { name: \"keepInVoxel\", progress: 0 };\n                break;\n            case \"keepInVoxel\":\n                keepInVoxel(minDist);\n                synthesizer.updateState.name = \"collision\";\n                break;\n            case \"collision\":\n                collision(minDist, maxOverlap);\n                synthesizer.updateState.name = \"getOverlap\";\n                break;\n            case \"getOverlap\": {\n                const mo = getOverlap(minDist, maxOverlap * 0.999);\n                if (mo < maxOverlap) {\n                    synthesizer.updateState = { name: \"volumeFraction\", progress: 0 };\n                    break;\n                }\n                ++synthesizer.updateState.progress;\n                if (synthesizer.updateState.progress === 100)\n                    synthesizer.updateState = { name: \"volumeFraction\", progress: 0 };\n                else synthesizer.updateState.name = \"keepInVoxel\";\n                break;\n            }\n            case \"volumeFraction\": {\n                const [avf, cvf] = volumeFraction(20, border);\n                synthesizer.updateState = { name: \"ready\", progress: 0, volumeFraction: [avf, cvf] };\n                computeMinAndMaxDiameter();\n                break;\n            }\n            default:\n                synthesizer.updateState = { name: \"ready\", progress: 0 };\n                break;\n        }\n        return synthesizer.updateState;\n    };\n    const generatePipes = (scene: Scene, resolution: number, extended: boolean, viewSizes: boolean) => {\n        synthesizer.axons.forEach(axon => {\n            axon.generatePipes(scene, resolution, extended, viewSizes, synthesizer.minAndMaxDiameterAxons);\n        });\n        return scene;\n    };\n    const drawLight = (scene: Scene) => {\n        scene.add(new AmbientLight(0xffffff, 0.4));\n        const light = new DirectionalLight(0xffffff, 0.4);\n        light.position.set(0, 1, 0);\n        scene.add(light);\n    };\n    const drawVoxels = (scene: Scene, mode: string, border: number) => {\n        if (mode === \"none\") return;\n        scene.add(wireframeCube(synthesizer.voxelSize));\n        const size = new Vector3().fromArray(synthesizer.voxelSize.toArray().map(v => v - 2 * border));\n        if (border > 0) scene.add(wireframeCube(size));\n    };\n    const drawAxons = (scene: Scene, mode: string, viewSizes: boolean, resolution: number, extended: boolean) => {\n        switch (mode) {\n            case \"skeleton\":\n                synthesizer.axons.forEach(axon =>\n                    axon.generateSkeleton(scene, viewSizes, synthesizer.minAndMaxDiameterAxons)\n                );\n                break;\n            case \"pipes\":\n                generatePipes(scene, resolution, extended, viewSizes);\n                break;\n            case \"ellipsoids\": {\n                synthesizer.axons.forEach(axon => axon.draw(scene, viewSizes, synthesizer.minAndMaxDiameterAxons));\n                break;\n            }\n            default:\n                break;\n        }\n    };\n    const drawCells = (scene: Scene, mode: string) => {\n        if (mode === \"none\") return;\n        synthesizer.cells.forEach(cell => cell.draw(scene, true, synthesizer.minAndMaxDiameterCells));\n    };\n    const draw = (\n        voxelMode: string,\n        axonMode: string,\n        cellMode: string,\n        resolution: number,\n        extended: boolean,\n        border: number,\n        viewSizes: boolean\n    ) => {\n        const scene = new Scene();\n        drawLight(scene);\n        drawVoxels(scene, voxelMode, border);\n        drawCells(scene, cellMode);\n        drawAxons(scene, axonMode, viewSizes, resolution, extended);\n        return scene;\n    };\n    const point = (camPos: Vector3, cursorDir: Vector3) => {\n        let result: Focus = {\n            type: \"\",\n            object: null\n        };\n        let minDist = 10000000;\n        const pos = camPos.clone().add(cursorDir.clone().multiplyScalar(1000000));\n        const dir = cursorDir.clone().negate();\n        [\n            synthesizer.axons.map(a => ({ type: \"axon\", object: a })),\n            synthesizer.cells.map(c => ({ type: \"cell\", object: c }))\n        ]\n            .flat()\n            .forEach(item => {\n                const sp = item.object.getSurfacePoint(pos, dir);\n                if (!sp) return;\n                const dist = cursorDir.dot(sp.clone().sub(camPos));\n                if (dist > minDist) return;\n                minDist = dist;\n                result = item;\n            });\n        if (minDist < 100000 && synthesizer.focus.object === result.object) return synthesizer.focus;\n        if (isAxon(result.type, result.object))\n            result.object.meshes.forEach(\n                mesh => (mesh.material = new MeshPhongMaterial({ color: new Color(0xffffff), side: DoubleSide }))\n            );\n        synthesizer.focus = result;\n        const mesh = (synthesizer.focus.object as Ellipsoid)?.mesh;\n        if (mesh?.material) mesh.material = new MeshToonMaterial({ color: new Color(0xffffff) });\n        deselectAll();\n        return synthesizer.focus;\n    };\n    const deselectAll = () => {\n        synthesizer.axons.forEach(axon => {\n            if (axon === (synthesizer.focus || {}).object) return;\n            axon.meshes.forEach(\n                mesh => (mesh.material = new MeshPhongMaterial({ vertexColors: true, side: DoubleSide }))\n            );\n        });\n        synthesizer.cells.forEach(cell => {\n            if (cell === synthesizer.focus.object) return;\n            if (!cell.mesh) return;\n            cell.mesh.material = new MeshToonMaterial({\n                color: cell.getColor(synthesizer.minAndMaxDiameterCells)\n            });\n        });\n    };\n    return Object.assign(synthesizer, {\n        dispose,\n        toJSON,\n        toPLY,\n        keepInVoxel,\n        collision,\n        getOverlap,\n        addAxonsRandomly,\n        addCellsRandomly,\n        volumeFraction,\n        update,\n        generatePipes,\n        drawLight,\n        drawVoxels,\n        drawAxons,\n        drawCells,\n        computeMinAndMaxDiameter,\n        draw,\n        point,\n        deselectAll\n    });\n};\n\nexport default createSynthesizer;\n","import React from \"react\";\nimport Legend from \"./Legend\";\nimport \"../../node_modules/react-vis/dist/style.css\";\nimport { helperFunctions } from \"@axon-generator-toolbox/core\";\n\nexport default props => {\n    const n = 100;\n    const colors = Array(n)\n        .fill(true)\n        .map((_, i) => \"#\" + helperFunctions.scaledValueToColor(i / (n - 1)).getHexString());\n    return (\n        <Legend\n            width={props.width}\n            startTitle={props.min.toFixed(2) + \" m\"}\n            midTitle={((props.min + props.max) / 2).toFixed(2) + \" m\"}\n            endTitle={props.max.toFixed(2) + \" m\"}\n            orientation=\"vertical\"\n            colors={colors}\n        />\n    );\n};\n","import {\n    Button,\n    FormControl,\n    FormControlLabel,\n    Grid,\n    InputAdornment,\n    InputLabel,\n    List,\n    ListItem,\n    MenuItem,\n    Paper,\n    Select,\n    Switch,\n    Table,\n    TableBody,\n    TableCell,\n    TableContainer,\n    TableRow,\n    TextField,\n    makeStyles\n} from \"@material-ui/core\";\nimport { PerspectiveCamera, Vector3, WebGLRenderer } from \"three\";\nimport React, { useEffect, useRef, useState } from \"react\";\n\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport SizeScale from \"./SizeScale\";\nimport { createSynthesizer, setRandomSeed } from \"@axon-generator-toolbox/core\";\nimport download from \"in-browser-download\";\nimport { useWindowSize } from \"@react-hook/window-size\";\n\nconst useStyles = makeStyles(theme => ({\n    gridItem: {\n        padding: theme.spacing(2),\n        textAlign: \"center\"\n    }\n}));\n\nexport default () => {\n    const [windowWidth, windowHeight] = useWindowSize();\n    const width = windowWidth * 0.55;\n    const height = windowHeight * 0.85;\n    const fov = 75;\n    const classes = useStyles();\n    const mount = useRef();\n    const maxOverlap = 0.0001;\n    const [controls, setControls] = useState(null);\n    const [scene, setScene] = useState(null);\n    const [camera, setCamera] = useState(null);\n    const [renderer, setRenderer] = useState(null);\n    const [synthesizer, setSynthesizer] = useState(null);\n    const [frame, setFrame] = useState(0);\n    const [viewModeVoxel, setViewModeVoxel] = useState(\"all\");\n    const [viewModeAxon, setViewModeAxon] = useState(\"ellipsoids\");\n    const [viewSizes, setViewSizes] = useState(false);\n    const [resolution, setResolution] = useState(32);\n    const [viewModeCell, setViewModeCell] = useState(\"all\");\n    const [volumeFraction, setVolumeFraction] = useState([]);\n    const [volumeFractionTarget, setVolumeFractionTarget] = useState(null);\n    const [seed, setSeed] = useState(0);\n    const [voxelSize, setVoxelSize] = useState([100, 100, 100]);\n    const [axonCount, setAxonCount] = useState(50);\n    const [cellCount, setCellCount] = useState(0);\n    const [growSpeed, setGrowSpeed] = useState(0.02);\n    const [contractSpeed, setContractSpeed] = useState(1);\n    const [minDist, setMinDist] = useState(0.07);\n    const inputFileRef = useRef();\n    const [inputFile, setInputFile] = useState(null);\n    const [updateState, setUpdateState] = useState({});\n    const [growCount, setGrowCount] = useState(null);\n    const [growCountTarget, setGrowCountTarget] = useState(null);\n    const [automaticGrowth, setAutomaticGrowth] = useState(false);\n    const [mapFromDiameterToDeformationFactor, setMapFromDiameterToDeformationFactor] = useState({\n        from: [0, 2],\n        to: [0, 0.2]\n    });\n    const [mapFromMaxDiameterToMinDiameter, setMapFromMaxDiameterToMinDiameter] = useState({\n        from: [0, 2],\n        to: [0, 0.2]\n    });\n    const [mapFromMaxDiameterToEllipsoidSeparation, setMapFromMaxDiameterToEllipsoidSeparation] = useState({\n        from: [0, 1],\n        to: [0, 0.25]\n    });\n    const [selectItem, setSelectItem] = useState(false);\n    const [selectedItem, setSelectedItem] = useState(null);\n    const [exportBinary, setExportBinary] = useState(true);\n    const [exportSimple, setExportSimple] = useState(false);\n    const [border, setBorder] = useState(0);\n    const [gRatio, setGRatio] = useState(0.7);\n    useEffect(() => {\n        const mc = mount.current;\n        if (!mc) return;\n        // Camera\n        const cam = new PerspectiveCamera(fov, width / height, 0.1, 1000);\n        cam.position.set(50, 50, 50);\n        cam.lookAt(0, 0, 0);\n        setCamera(cam);\n        // Renderer\n        const ren = new WebGLRenderer({ antialias: true });\n        ren.setClearColor(\"#000000\");\n        ren.setSize(width, height);\n        mc.appendChild(ren.domElement);\n        setRenderer(ren);\n        // Controls\n        const ctrls = new OrbitControls(cam, ren.domElement);\n        ctrls.enableDamping = true;\n        ctrls.dampingFactor = 0.5;\n        setControls(ctrls);\n        // Animate\n        const t = window.setInterval(() => setFrame(frame => frame + 1), 1000 / 30);\n        return () => {\n            window.clearInterval(t);\n            mc.removeChild(ren.domElement);\n            ren.renderLists.dispose();\n        };\n    }, [mount, width, height]);\n\n    useEffect(() => {\n        if (!selectItem) return;\n        if (!synthesizer) return;\n        if (!renderer) return;\n        if (!camera) return;\n        if (![\"ellipsoids\", \"pipes\"].includes(viewModeAxon)) return;\n        const mousemove = e => {\n            const x = (e.offsetX / width - 0.5) * 2 * Math.tan((fov * (width / height) * (Math.PI / 180)) / 2);\n            const y = -(e.offsetY / height - 0.5) * 2 * Math.tan((fov * (Math.PI / 180)) / 2);\n            const center = new Vector3(0, 0, 0);\n            const forward = center.clone().sub(camera.position).normalize();\n            const right = forward.clone().cross(new Vector3(0, 1, 0)).normalize();\n            const up = right.clone().cross(forward).normalize();\n            right.multiplyScalar(x);\n            up.multiplyScalar(y);\n            setSelectedItem(synthesizer.point(camera.position, forward.clone().add(right).add(up), viewSizes));\n        };\n        const click = () => {\n            if (!selectedItem) return;\n            const geoms =\n                selectedItem.type === \"axon\"\n                    ? selectedItem.object.meshes\n                        .filter((_, i) => i !== 1 || Number(selectedItem.object.gRatio) !== 1)\n                        .map(mesh => mesh.geometry)\n                    : [selectedItem.object.mesh.geometry];\n            synthesizer.focus = null;\n            synthesizer.deselectAll(viewSizes);\n            setSelectedItem(null);\n            setSelectItem(false);\n            const name = window.prompt(\"File name\", (selectedItem.type === \"axon\" ? \"@type\" : \"cell\") + \"_@color.ply\");\n            if (!name) return;\n            geoms.forEach((geom, i) =>\n                download(\n                    selectedItem.object.toPLY(exportBinary, exportSimple, i),\n                    name.replace(/@type/g, i === 0 ? \"myelin\" : \"axon\").replace(/@color/g, selectedItem.object.color)\n                )\n            );\n        };\n        renderer.domElement.addEventListener(\"mousemove\", mousemove);\n        renderer.domElement.addEventListener(\"click\", click);\n        return () => {\n            renderer.domElement.removeEventListener(\"mousemove\", mousemove);\n            renderer.domElement.removeEventListener(\"click\", click);\n        };\n    }, [\n        synthesizer,\n        renderer,\n        camera,\n        viewModeAxon,\n        selectItem,\n        selectedItem,\n        resolution,\n        exportBinary,\n        exportSimple,\n        width,\n        height,\n        viewSizes\n    ]);\n\n    useEffect(() => {\n        if (controls) controls.update();\n        if (renderer && scene && camera) renderer.render(scene, camera);\n        if (!synthesizer) return;\n        if (!updateState.name) return;\n        if (\n            automaticGrowth &&\n            updateState.volumeFraction &&\n            updateState.volumeFraction[0] + updateState.volumeFraction[1] >= volumeFractionTarget\n        )\n            return setAutomaticGrowth(false);\n        if (JSON.stringify(updateState) !== JSON.stringify(synthesizer.updateState)) return;\n        if (updateState.name === \"getOverlap\")\n            setScene(\n                synthesizer.draw(\n                    viewModeVoxel,\n                    viewModeAxon,\n                    viewModeCell,\n                    Number(resolution),\n                    false,\n                    Number(border),\n                    viewSizes\n                )\n            );\n        let gc = growCount;\n        if (\n            updateState.name === \"ready\" &&\n            updateState.volumeFraction &&\n            volumeFraction !== updateState.volumeFraction\n        ) {\n            setVolumeFraction(updateState.volumeFraction);\n            gc = (growCount || 0) + 1;\n        }\n        setGrowCount(gc);\n        if (updateState.name !== \"ready\" || automaticGrowth || gc < growCountTarget) {\n            const us = { ...synthesizer.update(growSpeed, contractSpeed, minDist, maxOverlap, Number(border)) };\n            window.setTimeout(() => setUpdateState(us), 0);\n            return;\n        }\n    }, [\n        controls,\n        renderer,\n        scene,\n        camera,\n        frame,\n        updateState,\n        synthesizer,\n        viewModeVoxel,\n        viewModeAxon,\n        resolution,\n        viewModeCell,\n        growSpeed,\n        contractSpeed,\n        minDist,\n        maxOverlap,\n        volumeFraction,\n        automaticGrowth,\n        growCount,\n        growCountTarget,\n        volumeFractionTarget,\n        border\n    ]);\n\n    useEffect(() => {\n        if (!inputFile) return;\n        const reader = new FileReader();\n        reader.onload = event => {\n            const data = JSON.parse(event.target.result);\n            data.voxelSize = isNaN(Number(data.voxelSize))\n                ? data.voxelSize\n                : [data.voxelSize, data.voxelSize, data.voxelSize];\n            if (synthesizer) synthesizer.dispose();\n            const s = createSynthesizer(data);\n            setSeed(data.randomSeed || 0);\n            setRandomSeed(data.randomSeed || 0);\n            setVoxelSize(data.voxelSize);\n            setBorder(data.border || 0);\n            setGrowSpeed(data.growSpeed);\n            setContractSpeed(data.contractSpeed);\n            setMinDist(data.minimumDistance || 0.07);\n            setMapFromDiameterToDeformationFactor(data.mapFromDiameterToDeformationFactor);\n            setMapFromMaxDiameterToMinDiameter(data.mapFromMaxDiameterToMinDiameter);\n            setMapFromMaxDiameterToEllipsoidSeparation(data.mapFromMaxDiameterToEllipsoidSeparation);\n            setAxonCount(data.axons.length);\n            setCellCount(data.cells.length);\n            setSynthesizer(s);\n            setScene(\n                s.draw(\n                    viewModeVoxel,\n                    viewModeAxon,\n                    viewModeCell,\n                    Number(resolution),\n                    false,\n                    Number(data.border),\n                    viewSizes\n                )\n            );\n            setUpdateState(s.updateState);\n            setVolumeFraction(0);\n            setGrowCountTarget(0);\n            setGrowCount(0);\n        };\n        reader.readAsText(inputFile);\n        setInputFile(null);\n    }, [inputFile, viewModeVoxel, viewModeAxon, resolution, viewModeCell, border, synthesizer]);\n\n    return (\n        <>\n            <Grid container item xs={11}>\n                <Grid\n                    item\n                    xs={4}\n                    style={{ height: window.innerHeight * 0.9, overflowX: \"hidden\", overflowY: \"scroll\" }}>\n                    <Grid container direction=\"column\">\n                        <Grid item className={classes.gridItem}>\n                            <Paper>\n                                <List>\n                                    <ListItem>\n                                        <b>Setup</b>\n                                    </ListItem>\n                                    <ListItem>\n                                        {[\"x\", \"y\", \"z\"].map((v, i) => (\n                                            <TextField\n                                                key={v}\n                                                type=\"number\"\n                                                label={`Voxel side length ${v}`}\n                                                InputProps={{\n                                                    endAdornment: <InputAdornment position=\"start\">m</InputAdornment>\n                                                }}\n                                                value={voxelSize[i]}\n                                                onChange={e => {\n                                                    const result = [...voxelSize];\n                                                    result[i] = Number(e.target.value);\n                                                    setVoxelSize(result);\n                                                }}\n                                            />\n                                        ))}\n                                    </ListItem>\n                                    <ListItem>\n                                        <TextField\n                                            type=\"number\"\n                                            label=\"Number of axons\"\n                                            value={axonCount}\n                                            onChange={e => setAxonCount(e.target.value)}\n                                        />\n                                        <TextField\n                                            type=\"number\"\n                                            label=\"Number of cells\"\n                                            value={cellCount}\n                                            onChange={e => setCellCount(e.target.value)}\n                                        />\n                                    </ListItem>\n                                    <ListItem>\n                                        <TextField\n                                            type=\"number\"\n                                            label=\"g-ratio\"\n                                            value={gRatio}\n                                            onChange={e => setGRatio(e.target.value)}\n                                        />\n                                    </ListItem>\n                                    <ListItem>\n                                        <Button\n                                            variant=\"contained\"\n                                            onClick={() => {\n                                                if (synthesizer) synthesizer.dispose();\n                                                const s = createSynthesizer({\n                                                    voxelSize: voxelSize,\n                                                    mapFromDiameterToDeformationFactor: mapFromDiameterToDeformationFactor,\n                                                    mapFromMaxDiameterToMinDiameter: mapFromMaxDiameterToMinDiameter,\n                                                    mapFromMaxDiameterToEllipsoidSeparation: mapFromMaxDiameterToEllipsoidSeparation\n                                                });\n                                                s.addAxonsRandomly(Number(axonCount), gRatio);\n                                                s.addCellsRandomly(Number(cellCount), minDist);\n                                                setSynthesizer(s);\n                                                setScene(\n                                                    s.draw(\n                                                        viewModeVoxel,\n                                                        viewModeAxon,\n                                                        viewModeCell,\n                                                        Number(resolution),\n                                                        false,\n                                                        Number(border),\n                                                        viewSizes\n                                                    )\n                                                );\n                                                setUpdateState(s.updateState);\n                                                setVolumeFraction(0);\n                                                setGrowCount(0);\n                                                setGrowCountTarget(0);\n                                                setRandomSeed(seed);\n                                            }}>\n                                            Initialize\n                                        </Button>\n                                        <Button variant=\"contained\" onClick={() => inputFileRef.current.click()}>\n                                            upload\n                                        </Button>\n                                        {synthesizer && (\n                                            <Button\n                                                variant=\"contained\"\n                                                onClick={() => {\n                                                    const config = {\n                                                        randomSeed: seed,\n                                                        growSpeed: growSpeed,\n                                                        contractSpeed: contractSpeed,\n                                                        minimumDistance: minDist,\n                                                        border: border,\n                                                        ...synthesizer.toJSON()\n                                                    };\n                                                    download(JSON.stringify(config, null, 4), \"config.json\");\n                                                }}>\n                                                Download\n                                            </Button>\n                                        )}\n                                    </ListItem>\n                                    <input\n                                        ref={inputFileRef}\n                                        type=\"file\"\n                                        style={{ display: \"none\" }}\n                                        onClick={e => (e.target.value = null)}\n                                        onChange={e => setInputFile(e.target.files[0])}\n                                    />\n                                </List>\n                            </Paper>\n                        </Grid>\n                        {synthesizer && (\n                            <>\n                                <Grid item className={classes.gridItem}>\n                                    <Paper>\n                                        <List>\n                                            <ListItem>\n                                                <b>After setup</b>\n                                            </ListItem>\n                                            <ListItem>\n                                                <TextField\n                                                    type=\"number\"\n                                                    label=\"Grow speed\"\n                                                    value={growSpeed}\n                                                    onChange={e => setGrowSpeed(Number(e.target.value))}\n                                                />\n                                                <TextField\n                                                    type=\"number\"\n                                                    label=\"Contract speed\"\n                                                    value={contractSpeed}\n                                                    onChange={e => setContractSpeed(Number(e.target.value))}\n                                                />\n                                                <TextField\n                                                    type=\"number\"\n                                                    label=\"Minimum distance\"\n                                                    InputProps={{\n                                                        endAdornment: (\n                                                            <InputAdornment position=\"start\">m</InputAdornment>\n                                                        )\n                                                    }}\n                                                    value={minDist}\n                                                    onChange={e => setMinDist(Number(e.target.value))}\n                                                />\n                                            </ListItem>\n                                            <ListItem>\n                                                <Button\n                                                    variant=\"contained\"\n                                                    onClick={() => {\n                                                        if (automaticGrowth) return setAutomaticGrowth(false);\n                                                        const target = window.prompt(\n                                                            \"Specify total volume fraction target\"\n                                                        );\n                                                        if (!target) return;\n                                                        setVolumeFractionTarget(target);\n                                                        setAutomaticGrowth(true);\n                                                    }}>\n                                                    Automatic growth: {automaticGrowth ? \"on\" : \"off\"}\n                                                </Button>\n                                                {automaticGrowth ? (\n                                                    <>\n                                                        <TextField\n                                                            type=\"number\"\n                                                            label=\"Target volume fraction\"\n                                                            value={volumeFractionTarget}\n                                                            onChange={e =>\n                                                                setVolumeFractionTarget(Number(e.target.value))\n                                                            }\n                                                        />\n                                                    </>\n                                                ) : (\n                                                    <>\n                                                        <Button\n                                                            variant=\"contained\"\n                                                            onClick={() =>\n                                                                setUpdateState({\n                                                                    ...synthesizer.update(\n                                                                        growSpeed,\n                                                                        contractSpeed,\n                                                                        minDist,\n                                                                        maxOverlap,\n                                                                        Number(border)\n                                                                    )\n                                                                })\n                                                            }>\n                                                            Perform 1 grow step\n                                                        </Button>\n                                                        <Button\n                                                            variant=\"contained\"\n                                                            onClick={() => {\n                                                                const x = parseInt(\n                                                                    window.prompt(\"How many grow steps?\")\n                                                                );\n                                                                if (x) setGrowCountTarget(growCount + x);\n                                                            }}>\n                                                            Perform x grow steps\n                                                        </Button>\n                                                    </>\n                                                )}\n                                            </ListItem>\n                                            <Grid item>\n                                                <b>Volume fraction estimation</b>\n                                            </Grid>\n                                            <Grid item>\n                                                Select how many m to exclude from each side of the voxel when doing the\n                                                estimation:\n                                            </Grid>\n                                            <TextField\n                                                type=\"number\"\n                                                label=\"Border\"\n                                                value={border}\n                                                onChange={e => {\n                                                    const b = e.target.value;\n                                                    setBorder(b);\n                                                    setScene(\n                                                        synthesizer.draw(\n                                                            viewModeVoxel,\n                                                            viewModeAxon,\n                                                            viewModeCell,\n                                                            Number(resolution),\n                                                            false,\n                                                            Number(b),\n                                                            viewSizes\n                                                        )\n                                                    );\n                                                }}\n                                            />\n                                            <TableContainer component={Paper}>\n                                                <Table className={classes.table} aria-label=\"simple table\">\n                                                    <TableBody>\n                                                        <TableRow>\n                                                            <TableCell component=\"th\" scope=\"row\">\n                                                                Axons\n                                                            </TableCell>\n                                                            <TableCell component=\"th\" scope=\"row\">\n                                                                Cells\n                                                            </TableCell>\n                                                            <TableCell component=\"th\" scope=\"row\">\n                                                                Total\n                                                            </TableCell>\n                                                        </TableRow>\n                                                        <TableRow>\n                                                            <TableCell>\n                                                                {((volumeFraction || [0, 0])[0] || 0).toFixed(2)}\n                                                            </TableCell>\n                                                            <TableCell>\n                                                                {((volumeFraction || [0, 0])[1] || 0).toFixed(2)}\n                                                            </TableCell>\n                                                            <TableCell>\n                                                                {(\n                                                                    ((volumeFraction || [0, 0])[0] || 0) +\n                                                                    ((volumeFraction || [0, 0])[1] || 0)\n                                                                ).toFixed(2)}\n                                                            </TableCell>\n                                                        </TableRow>\n                                                    </TableBody>\n                                                </Table>\n                                            </TableContainer>\n                                            <Grid item>\n                                                Status: {updateState.name}\n                                                {updateState.progress !== undefined\n                                                    ? `, iteration ${updateState.progress}`\n                                                    : \"\"}\n                                            </Grid>\n                                            <Grid item>Grow steps completed: {growCount}</Grid>\n                                        </List>\n                                    </Paper>\n                                </Grid>\n                                <Grid item className={classes.gridItem}>\n                                    <Paper>\n                                        <List>\n                                            <ListItem>\n                                                <b>Visual</b>\n                                            </ListItem>\n                                            <ListItem>\n                                                <FormControl>\n                                                    <InputLabel>Voxels</InputLabel>\n                                                    <Select\n                                                        value={viewModeVoxel}\n                                                        onChange={event => {\n                                                            const vm = event.target.value;\n                                                            setViewModeVoxel(vm);\n                                                            setScene(\n                                                                synthesizer.draw(\n                                                                    vm,\n                                                                    viewModeAxon,\n                                                                    viewModeCell,\n                                                                    Number(resolution),\n                                                                    false,\n                                                                    Number(border),\n                                                                    viewSizes\n                                                                )\n                                                            );\n                                                        }}>\n                                                        <MenuItem value=\"none\">hide</MenuItem>\n                                                        <MenuItem value=\"all\">show</MenuItem>\n                                                    </Select>\n                                                </FormControl>\n                                                <FormControl>\n                                                    <InputLabel>Axons</InputLabel>\n                                                    <Select\n                                                        value={viewModeAxon}\n                                                        onChange={event => {\n                                                            const vm = event.target.value;\n                                                            const res =\n                                                                vm === \"pipes\"\n                                                                    ? window.prompt(\"Resolution\", resolution)\n                                                                    : resolution;\n                                                            if (!res) return;\n                                                            const extended =\n                                                                vm === \"pipes\"\n                                                                    ? window.prompt(\n                                                                        'Extended axons - \"yes\"/\"no\"',\n                                                                        \"no\"\n                                                                    ) === \"yes\"\n                                                                    : false;\n                                                            if (!res) return;\n                                                            setViewModeAxon(vm);\n                                                            setResolution(res);\n                                                            setScene(\n                                                                synthesizer.draw(\n                                                                    viewModeVoxel,\n                                                                    vm,\n                                                                    viewModeCell,\n                                                                    Number(res),\n                                                                    extended,\n                                                                    Number(border),\n                                                                    viewSizes\n                                                                )\n                                                            );\n                                                        }}>\n                                                        <MenuItem value=\"none\">hide</MenuItem>\n                                                        <MenuItem value=\"ellipsoids\">ellipsoids</MenuItem>\n                                                        <MenuItem value=\"skeleton\">skeleton</MenuItem>\n                                                        <MenuItem value=\"pipes\">pipes</MenuItem>\n                                                    </Select>\n                                                </FormControl>\n                                                <FormControl>\n                                                    <InputLabel>Cells</InputLabel>\n                                                    <Select\n                                                        value={viewModeCell}\n                                                        onChange={event => {\n                                                            const vm = event.target.value;\n                                                            setViewModeCell(vm);\n                                                            setScene(\n                                                                synthesizer.draw(\n                                                                    viewModeVoxel,\n                                                                    viewModeAxon,\n                                                                    vm,\n                                                                    Number(resolution),\n                                                                    false,\n                                                                    Number(border),\n                                                                    viewSizes\n                                                                )\n                                                            );\n                                                        }}>\n                                                        <MenuItem value=\"none\">hide</MenuItem>\n                                                        <MenuItem value=\"all\">show</MenuItem>\n                                                    </Select>\n                                                </FormControl>\n                                            </ListItem>\n                                            <ListItem>\n                                                <FormControlLabel\n                                                    control={\n                                                        <Switch\n                                                            checked={viewSizes}\n                                                            onChange={e => {\n                                                                const vs = e.target.checked;\n                                                                setViewSizes(vs);\n                                                                setScene(\n                                                                    synthesizer.draw(\n                                                                        viewModeVoxel,\n                                                                        viewModeAxon,\n                                                                        viewModeCell,\n                                                                        Number(resolution),\n                                                                        false,\n                                                                        Number(border),\n                                                                        vs\n                                                                    )\n                                                                );\n                                                            }}\n                                                            color=\"primary\"\n                                                        />\n                                                    }\n                                                    label=\"Size color codes\"\n                                                />\n                                            </ListItem>\n                                        </List>\n                                    </Paper>\n                                </Grid>\n                                {viewModeAxon === \"pipes\" && (\n                                    <Grid item className={classes.gridItem}>\n                                        <Paper>\n                                            <List>\n                                                <ListItem>\n                                                    <b>Export</b>\n                                                </ListItem>\n                                                <ListItem>\n                                                    <Button\n                                                        variant=\"contained\"\n                                                        onClick={() => {\n                                                            const name = window.prompt(\"File name\", \"axons.ply\");\n                                                            if (!name) return;\n                                                            download(\n                                                                synthesizer.toPLY(exportBinary, exportSimple),\n                                                                name\n                                                            );\n                                                        }}>\n                                                        Export as single file\n                                                    </Button>\n                                                </ListItem>\n                                                <ListItem>\n                                                    <Button\n                                                        variant=\"contained\"\n                                                        onClick={async () => {\n                                                            const name = window.prompt(\n                                                                \"File name\",\n                                                                \"@type_@index_@color.ply\"\n                                                            );\n                                                            if (!name) return;\n                                                            const wait = async () =>\n                                                                await (milliseconds =>\n                                                                    new Promise(resolve =>\n                                                                        window.setTimeout(resolve, milliseconds)\n                                                                    ))(100);\n                                                            for (let i = 0; i < synthesizer.axons.length; ++i) {\n                                                                const axon = synthesizer.axons[i];\n                                                                const downloadPLY = async isAxon => {\n                                                                    await download(\n                                                                        axon.toPLY(\n                                                                            exportBinary,\n                                                                            exportSimple,\n                                                                            isAxon ? 1 : 0\n                                                                        ),\n                                                                        name\n                                                                            .replace(\n                                                                                /@type/g,\n                                                                                isAxon ? \"axon\" : \"myelin\"\n                                                                            )\n                                                                            .replace(/@index/g, i)\n                                                                            .replace(/@color/g, axon.color)\n                                                                    );\n                                                                };\n                                                                await downloadPLY(false);\n                                                                if (Number(axon.gRatio) !== 1) await downloadPLY(true);\n                                                                await wait();\n                                                            }\n                                                            if (viewModeCell === \"hide\") return;\n                                                            for (let i = 0; i < synthesizer.cells.length; ++i) {\n                                                                const cell = synthesizer.cells[i];\n                                                                await download(\n                                                                    cell.toPLY(exportBinary, exportSimple),\n                                                                    name\n                                                                        .replace(/@type/g, \"cell\")\n                                                                        .replace(/@index/g, i)\n                                                                        .replace(/@color/g, cell.color)\n                                                                );\n                                                                await wait();\n                                                            }\n                                                        }}>\n                                                        Export as multiple files\n                                                    </Button>\n                                                </ListItem>\n                                                <ListItem>\n                                                    <Button\n                                                        variant=\"contained\"\n                                                        onClick={() => setSelectItem(!selectItem)}>\n                                                        {selectItem ? \"Select an element\" : \"Export single element\"}\n                                                    </Button>\n                                                </ListItem>\n                                                <ListItem>\n                                                    <FormControlLabel\n                                                        control={\n                                                            <Switch\n                                                                checked={exportBinary}\n                                                                onChange={e => setExportBinary(e.target.checked)}\n                                                                color=\"primary\"\n                                                            />\n                                                        }\n                                                        label=\"Binary format\"\n                                                    />\n                                                </ListItem>\n                                                <ListItem>\n                                                    <FormControlLabel\n                                                        control={\n                                                            <Switch\n                                                                checked={exportSimple}\n                                                                onChange={e => setExportSimple(e.target.checked)}\n                                                                color=\"primary\"\n                                                            />\n                                                        }\n                                                        label=\"Simple mesh\"\n                                                    />\n                                                </ListItem>\n                                            </List>\n                                        </Paper>\n                                    </Grid>\n                                )}\n                            </>\n                        )}\n                    </Grid>\n                </Grid>\n                <Grid item xs={5}>\n                    <div ref={mount} />\n                    {viewSizes && (\n                        <>\n                            {synthesizer.minAndMaxDiameterAxons && (\n                                <>\n                                    Myelin\n                                    <SizeScale\n                                        width={width}\n                                        min={synthesizer.minAndMaxDiameterAxons.min}\n                                        max={synthesizer.minAndMaxDiameterAxons.max}\n                                    />\n                                </>\n                            )}\n                            {synthesizer.minAndMaxDiameterCells && (\n                                <>\n                                    Cells\n                                    <SizeScale\n                                        width={width}\n                                        min={synthesizer.minAndMaxDiameterCells.min}\n                                        max={synthesizer.minAndMaxDiameterCells.max}\n                                    />\n                                </>\n                            )}\n                        </>\n                    )}\n                </Grid>\n            </Grid>\n        </>\n    );\n};\n","import Toolbox from \"./Toolbox\";\n\nexport default {\n    title: \"Toolbox\",\n    path: \"/toolbox\",\n    component: Toolbox\n};\n","import React from \"react\";\nimport { Link } from \"react-router-dom\";\nimport download from \"in-browser-download\";\n\nconst inputExample = {\n    voxelSize: 10,\n    growSpeed: 0.05,\n    contractSpeed: 0.05,\n    mapFromDiameterToDeformationFactor: {\n        from: [0, 0.8, 2],\n        to: [0, 0.5, 1]\n    },\n    mapFromMaxDiameterToMinDiameter: {\n        from: [0, 1],\n        to: [0, 0.2]\n    },\n    mapFromMaxDiameterToEllipsoidSeparation: {\n        from: [0, 1],\n        to: [0.1, 1]\n    },\n    axons: [\n        {\n            position: [0, 0, 0],\n            direction: [1, 0, 0],\n            maxDiameter: 1,\n            color: \"#ff0000\",\n            gRatio: 0.7\n        },\n        {\n            position: [1, 0.1, 0],\n            direction: [1, 1, 1],\n            maxDiameter: 0.5,\n            color: \"#00ff00\",\n            gRatio: 0.5\n        }\n    ],\n    cells: [\n        {\n            position: [2, 1, 0],\n            shape: [1.5, 0, 0, 0, 1, 0, 0, 0, 1],\n            color: \"#0000ff\"\n        }\n    ]\n};\n\nexport default () => {\n    const content = JSON.stringify(inputExample, null, 4);\n    return (\n        <>\n            In the setup phase you can provide an input file. In this example create a new file and put in the\n            following:\n            <pre>{content}</pre>\n            and save the file as e.g. \"config.json\" (or click{\" \"}\n            <button onClick={() => download(content, \"config.json\")}>here</button> to download the file). Click the\n            \"Upload\" button and select the file. This should initialize a red and a green axon and a blue cell at the\n            specified positions.\n            <br />\n            <Link to=\"/help/setup\">Click here to see a description of the input file format.</Link>\n        </>\n    );\n};\n","export default __webpack_public_path__ + \"static/media/ellipsoids.0c65173b.png\";","export default __webpack_public_path__ + \"static/media/pipesSide.dce5d3c2.png\";","export default __webpack_public_path__ + \"static/media/pipesFront.811a2191.png\";","import React from \"react\";\nimport { Typography, makeStyles, Button } from \"@material-ui/core\";\nimport { save } from \"save-file\";\nimport config from \"./config\";\nimport imgEllipsoids from \"./ellipsoids.png\";\nimport imgPipesSide from \"./pipesSide.png\";\nimport imgPipesFront from \"./pipesFront.png\";\n\nconst useStyles = makeStyles(() => ({\n    img: {\n        width: 400\n    }\n}));\n\nexport default () => {\n    const classes = useStyles();\n    return (\n        <>\n            <Typography>The following config file will be used in this example:</Typography>\n            <Button\n                variant=\"contained\"\n                onClick={() => {\n                    save(JSON.stringify(config, null, 4), \"config.json\");\n                }}>\n                Config file\n            </Button>\n            <Typography>\n                Using this file and setting the volume fraction target to 0.7, the following result is obtained:\n            </Typography>\n            <img src={imgEllipsoids} className={classes.img} alt=\"ellipsoids\" />\n            <Typography>Switching to the pipe display mode the result is:</Typography>\n            <img src={imgPipesSide} className={classes.img} alt=\"pipes side\" />\n            <Typography>and</Typography>\n            <img src={imgPipesFront} className={classes.img} alt=\"pipes front\" />\n        </>\n    );\n};\n","export default __webpack_public_path__ + \"static/media/ellipsoids.d9dcf4b5.png\";","export default __webpack_public_path__ + \"static/media/pipesSide.ea865c63.png\";","export default __webpack_public_path__ + \"static/media/pipesFront.4c31b931.png\";","import React from \"react\";\nimport { Typography, makeStyles, Button } from \"@material-ui/core\";\nimport { save } from \"save-file\";\nimport config from \"./config\";\nimport imgEllipsoids from \"./ellipsoids.png\";\nimport imgPipesSide from \"./pipesSide.png\";\nimport imgPipesFront from \"./pipesFront.png\";\n\nconst useStyles = makeStyles(() => ({\n    img: {\n        width: 400\n    }\n}));\n\nexport default () => {\n    const classes = useStyles();\n    return (\n        <>\n            <Typography>The following config file will be used in this example:</Typography>\n            <Button\n                variant=\"contained\"\n                onClick={() => {\n                    save(JSON.stringify(config, null, 4), \"config.json\");\n                }}>\n                Config file\n            </Button>\n            <Typography>\n                Using this file and setting the volume fraction target to 0.8, the following result is obtained:\n            </Typography>\n            <img src={imgEllipsoids} className={classes.img} alt=\"ellipsoids\" />\n            <Typography>Switching to the pipe display mode the result is:</Typography>\n            <img src={imgPipesSide} className={classes.img} alt=\"pipes side\" />\n            <Typography>and</Typography>\n            <img src={imgPipesFront} className={classes.img} alt=\"pipes front\" />\n        </>\n    );\n};\n","import Examples from \"./Examples\";\n\nimport GettingStarted from \"./GettingStarted\";\nimport Input from \"./Input\";\nimport ParallelSameSize from \"./ParallelSameSize\";\nimport ParallelDifferentSize from \"./ParallelDifferentSize\";\n\nexport default {\n    title: \"Examples\",\n    path: \"/examples\",\n    component: Examples,\n    items: [\n        {\n            title: \"Getting started\",\n            path: \"/getting_started\",\n            component: GettingStarted\n        },\n        {\n            title: \"Input file\",\n            path: \"/input\",\n            component: Input\n        },\n        {\n            title: \"Parallel axons of equal size\",\n            path: \"/parallelSameSize\",\n            component: ParallelSameSize\n        },\n        {\n            title: \"Parallel axons of different sizes\",\n            path: \"/parallelDifferentSize\",\n            component: ParallelDifferentSize\n        }\n    ]\n};\n","import React from \"react\";\nimport { Switch, Route } from \"react-router-dom\";\n\nimport config from \"./config\";\n\nexport default props => (\n    <Switch>\n        {config.items.map((item, i) => (\n            <Route key={i} path={`${props.match.path}${item.path}`} component={item.component} />\n        ))}\n    </Switch>\n);\n","import React from \"react\";\n\nexport default () => (\n    <>\n        If you just want to try out the toolbox and see that it works try out the following:\n        <ul>\n            <li>Under \"Setup\" Press \"Initialize\"</li>\n            <li>Under \"After setup\" press \"Perform x grow steps\" and set the number to 10</li>\n            <li>Wait for the axons to grow</li>\n            <li>Under \"Visual\" set the axons to be displayed as \"pipes\" to see the final result</li>\n        </ul>\n    </>\n);\n","import React from \"react\";\n\nconst Code = props => (\n    <pre\n        style={{\n            fontFamily: \"courier new\",\n            color: \"crimson\",\n            backgroundColor: \"#f1f1f1\",\n            padding: \"2px\",\n            fontSize: \"105%\"\n        }}>\n        {props.children}\n    </pre>\n);\n\nexport default () => (\n    <>\n        <b>CLI (command-line interface) - Installation guide</b>\n        <p>\n            If you haven't already, you need to install npm. This can be done by running the following commands in a\n            terminal:\n        </p>\n        <Code>curl -sL https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.0/install.sh -o install_nvm.sh</Code>\n        <Code>bash install_nvm.sh</Code>\n        <Code>nvm install --lts</Code>\n        <p>Then you should be able to install the CLI by running the command:</p>\n        <Code>npm i -g white-matter-generator</Code>\n        <p>Now, you can run the CLI using the command:</p>\n        <Code>white-matter-generator</Code>\n    </>\n);\n","import Help from \"./Help\";\n\nimport Setup from \"./Setup\";\nimport AfterSetup from \"./AfterSetup\";\nimport Visual from \"./Visual\";\nimport Cli from \"./Cli\";\n\nexport default {\n    title: \"Help\",\n    path: \"/help\",\n    component: Help,\n    items: [\n        {\n            title: \"Setup\",\n            path: \"/setup\",\n            component: Setup\n        },\n        {\n            title: \"After setup\",\n            path: \"/after_setup\",\n            component: AfterSetup\n        },\n        {\n            title: \"Visual\",\n            path: \"/visual\",\n            component: Visual\n        },\n        {\n            title: \"CLI\",\n            path: \"/cli\",\n            component: Cli\n        }\n    ]\n};\n","import React from \"react\";\nimport { Switch, Route } from \"react-router-dom\";\n\nimport config from \"./config\";\n\nexport default props => (\n    <Switch>\n        {config.items.map((item, i) => (\n            <Route key={i} path={`${props.match.path}${item.path}`} component={item.component} />\n        ))}\n    </Switch>\n);\n","import React from \"react\";\nimport { Link } from \"react-router-dom\";\n\nexport default () => (\n    <>\n        <p>The first phase is the setup phase. Here you can specify:</p>\n        <ul>\n            <li>\n                <b>Voxel side length</b> - This is the side length of the voxel.\n            </li>\n            <li>\n                <b>Number of axons</b> - This is the number of axons to be generated. Each axon is made up of ellipsoids\n                (here called ellipsoids).\n            </li>\n            <li>\n                <b>Ellipsoid density of axons</b> - This is the number of ellipsoids per m along axons. A higher number\n                results in higher precision of the model but is also more computation heavy.\n            </li>\n            <li>\n                <b>Number of cells</b> - This is the number of cells to be generated. Each cell has the shape of an\n                ellipsoid.\n            </li>\n        </ul>\n        <p>\n            When you are ready click the \"Initialize\" button. If you want more control of exactly how the axons and\n            cells are generated, you can instead provide a JSON file by clicking the \"upload config file\" button. The\n            file can specify the following values (the unit of length is m):\n        </p>\n        <ul>\n            <li>\n                <b>voxelSize</b> (number) - This is the side length of the voxel.\n            </li>\n            <li>\n                <b>growSpeed</b> (number) - How much the axons grow per step. 0 means no growth, 1 means that the axon\n                will grow to 100% of its target size in 1 step.\n            </li>\n            <li>\n                <b>contractSpeed</b> (number) - How much the axons contract per step, i.e. how stiff the axons are. This\n                number should be non-negative.\n            </li>\n            <li>\n                <b>mapFromDiameterToDeformationFactor</b>* (object) - This map determines how much the axons' ellipsoids\n                should deform as opposed to change position when a collision occurs. It maps from the current diameter\n                of the ellipsoid (axon + myelin) to the deformation factor, which is a number between 0 and 1. A\n                deformation factor of 0 means that the ellipsoid can't be deformed at all and will always be a perfect\n                sphere. A deformation factor of 1 means that the ellipsoid will deform as much as possible rather than\n                change the position of its center. The values defining the map will be linearly interpolated.\n                <ul>\n                    <li>\n                        <b>from</b> (array of numbers) - The input values of the map, i.e. diameters. This array should\n                        be given in increasing order.\n                    </li>\n                    <li>\n                        <b>to</b> (array of numbers) - The output values of the map, i.e. deformation factors.\n                    </li>\n                </ul>\n            </li>\n            <li>\n                <b>mapFromMaxDiameterToMinDiameter</b>* (object) - This map determines the minimum diameter an ellipsoid\n                can have (axon + myelin) given its maximum diameter (axon + myelin). The values defining the map will be\n                linearly interpolated.\n                <ul>\n                    <li>\n                        <b>from</b> (array of numbers) - The input values of the map, i.e. maximum diameters. This array\n                        should be given in increasing order.\n                    </li>\n                    <li>\n                        <b>to</b> (array of numbers) - The output values of the map, i.e. minimum diameters.\n                    </li>\n                </ul>\n            </li>\n            <li>\n                <b>mapFromMaxDiameterToEllipsoidSeparation</b>* (object) - This map determines the separation of\n                ellipsoids in m on an axon given its maximum diameter (axon + myelin). The values defining the map will\n                be linearly interpolated.\n                <ul>\n                    <li>\n                        <b>from</b> (array of numbers) - The input values of the map, i.e. maximum diameters. This array\n                        should be given in increasing order.\n                    </li>\n                    <li>\n                        <b>to</b> (array of numbers) - The output values of the map, i.e. separation of ellipsoids.\n                    </li>\n                </ul>\n            </li>\n            <li>\n                <b>axons</b> (array of objects) - The axons to be generated. Initially each axon will consist of a\n                straight chain of spheres passing through its <b>position</b> vector and be aligned with its{\" \"}\n                <b>direction</b> vector.\n                <ul>\n                    <li>\n                        <b>position</b> (array of 3 numbers) - When the axon is initialized it will pass through this\n                        point.\n                    </li>\n                    <li>\n                        <b>direction</b> (array of 3 numbers) - When the axon is initialized it's direction will be\n                        aligned with this vector.\n                    </li>\n                    <li>\n                        <b>maxDiameter</b> (number) - The maximum attainable diameter of the axon. This number is\n                        automatically divided by the <b>gRatio</b> to represent the maximum attainable diameter of the\n                        axon + myelin.\n                    </li>\n                    <li>\n                        <b>color</b> (string) - Color code of the axon. E.g. \"#ffffff\" to make it white.\n                    </li>\n                    <li>\n                        <b>gRatio</b> (number) - This number describes the size of the axon relative to the size of the\n                        axon + myelin. It should be between 0 and 1.\n                    </li>\n                </ul>\n            </li>\n            <li>\n                <b>cells</b> (array of objects) - The cells to be generated. Each cell is defined by a position vector\n                and a shape matrix (the identity matrix corresponds to a unit sphere). The axons will try to grow around\n                them.\n                <ul>\n                    <li>\n                        <b>position</b> (array of 3 numbers) - The center of the cell.\n                    </li>\n                    <li>\n                        <b>shape</b> (array of 9 numbers) - Specifies the 3x3 transformation matrix used when going from\n                        a unit sphere to an ellipsoid. This ellipsoid will be the shape of the cell.\n                    </li>\n                    <li>\n                        <b>color</b> (string) - Color code of the cell. E.g. \"#ffffff\" to make it white.\n                    </li>\n                </ul>\n            </li>\n        </ul>\n        <p>\n            * A map object contains two arrays of numbers: <b>from</b> and <b>to</b>. The lengths of these arrays can be\n            any number as long as they are the same. E.g. you can have <b>from</b>=[0,1,2,3] and <b>to</b>=[2,2,4,4].\n            Here both <b>from</b> and <b>to</b> have length 4. NB: the array lengths do not have anything to do with the\n            number of axons or cells.\n        </p>\n        <ul>\n            <li>\n                When a map is used the input is looked up in the <b>from</b> array and the corresponding value in the{\" \"}\n                <b>to</b> array is returned. E.g. if we use the example maps from before with an input of 2, the output\n                will be computed like this: [0,1,<b>2</b>,3] -> [2,2,<b>4</b>,4]. Hence the output will be 4.\n            </li>\n            <li>\n                If we provide a value that doesn't exist in the <b>from</b> array, linear interpolation will be used.\n                E.g. if we use the input value 1.5, the output will be the average of the two output values: [0,\n                <b>1</b>,<b>2</b>,3] -> [2,<b>2</b>,<b>4</b>,4]. Hence the output will be the average of 2 and 4, i.e.\n                3.\n            </li>\n        </ul>\n        <Link to=\"/examples/input\">Click here to see an example of an input file.</Link>\n    </>\n);\n","import React from \"react\";\n\nexport default () => (\n    <>\n        In the \"After setup\" pane you can specify:\n        <ul>\n            <li>\n                <b>Grow speed</b> - This is how much the axons grow per step. A value of 0 means no growth and a value\n                of 1 means that it should grow to 100% of its target size in 1 step. If close to 0 there will be fewer\n                numerical errors but the algorithm will require more steps i total.\n            </li>\n            <li>\n                <b>Contract speed</b> - This is how much the axons will contract per step, i.e. how \"stiff\" the axons\n                are. A value of 0 means that neighboring ellipsoids of an axon won't try to stay together. The maximum\n                value is 1.\n            </li>\n            <li>\n                <b>Minimum distance</b> - This is the minimum allowed space between axons. If set to 0 the axons can\n                touch each other.\n            </li>\n        </ul>\n        <p>\n            After specifying these values you have 3 options: 1: You can turn on automatic growth which will perform\n            grow steps until the volume fraction has reached a specified value. 2: You can click the \"Perform 1 grow\n            step\" button to perform just 1 step at a time. 3: You can click the \"Perform x grow steps\" button to perform\n            a specific number of grow steps.\n        </p>\n        <p>\n            Below the two buttons the estimated volume fractions will be displayed. These fractions are estimated by\n            counting the number of points in a lattice that fall within either an axon or a cell and dividing by the\n            volume of the voxel.\n        </p>\n        <p>\n            In the bottom of the pane you can see which part of a grow step is currently being executed. You can also\n            see the number of completed grow steps.\n        </p>\n    </>\n);\n","import React from \"react\";\n\nexport default () => (\n    <>\n        In the \"Visual\" pane you can specify how the generated substrate should be displayed:\n        <ul>\n            <li>\n                <b>Voxels</b>\n                <ul>\n                    <li>\n                        <b>Hide</b> - Hide the voxels.\n                    </li>\n                    <li>\n                        <b>Show</b> - Show the voxels.\n                    </li>\n                </ul>\n            </li>\n            <li>\n                <b>Axons</b>\n                <ul>\n                    <li>\n                        <b>Hide</b> - Hide the axons.\n                    </li>\n                    <li>\n                        <b>Ellipsoids</b> - Display the axons as chains of ellipsoids (this is what is used by the\n                        algorithm).\n                    </li>\n                    <li>\n                        <b>Skeleton</b> - Display the axons as skeletons (a line strip that represents the center of the\n                        axon).\n                    </li>\n                    <li>\n                        <b>Pipes</b> - Display the axons as hollow \"pipes\" (should be used when exporting).\n                    </li>\n                </ul>\n            </li>\n            <li>\n                <b>Cells</b>\n                <ul>\n                    <li>\n                        <b>Hide</b> - Hide the cells.\n                    </li>\n                    <li>\n                        <b>Show</b> - Show the cells.\n                    </li>\n                </ul>\n            </li>\n        </ul>\n        Clicking the \"Export as single file\" button will export the currently displayed scene in PLY format. Clicking\n        the \"Export as multiple files\" button will export all elements as individual PLY files. Clicking the \"Export\n        single element\" button and then clicking on an axon or a cell will export only that element in PLY format.\n    </>\n);\n","import React from \"react\";\nconst source = \"https://github.com/Peulicke/axon-generator-toolbox\";\n\nexport default () => (\n    <>\n        The source code can be found at <a href={source}>{source}</a>\n    </>\n);\n","import toolbox from \"./Toolbox/config\";\nimport examples from \"./Examples/config\";\nimport help from \"./Help/config\";\nimport source from \"./Source/config\";\n\nexport default [toolbox, examples, help, source];\n","import Source from \"./Source\";\n\nexport default {\n    title: \"Source code\",\n    path: \"/source\",\n    component: Source\n};\n","import React from \"react\";\nimport { Drawer, List, ListItem, ListItemText, ListSubheader } from \"@material-ui/core\";\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport { useHistory } from \"react-router-dom\";\nimport config from \"./config\";\n\nconst drawerWidth = 200;\n\nconst useStyles = makeStyles(theme => ({\n    root: {\n        display: \"flex\"\n    },\n    drawer: {\n        [theme.breakpoints.up(\"sm\")]: {\n            width: drawerWidth,\n            flexShrink: 0\n        }\n    },\n    drawerPaper: {\n        width: drawerWidth\n    },\n    content: {\n        flexGrow: 1,\n        padding: theme.spacing(3)\n    },\n    nested: {\n        paddingLeft: theme.spacing(4)\n    }\n}));\n\nexport default props => {\n    const classes = useStyles();\n    const history = useHistory();\n    return (\n        <div className={classes.root}>\n            <div className={classes.drawer}>\n                <Drawer\n                    classes={{\n                        paper: classes.drawerPaper\n                    }}\n                    variant=\"permanent\">\n                    <List>\n                        {config.map((c, i) =>\n                            c.items ? (\n                                <List\n                                    key={i}\n                                    component=\"div\"\n                                    disablePadding\n                                    subheader={<ListSubheader component=\"div\">{c.title}</ListSubheader>}>\n                                    {c.items.map((item, i) => (\n                                        <ListItem\n                                            key={i}\n                                            button\n                                            className={classes.nested}\n                                            onClick={() =>\n                                                history.push(`${c.path}${item.path}`)\n                                            }\n                                            selected={\n                                                props.match.url === `${c.path}${item.path}`\n                                            }>\n                                            <ListItemText primary={item.title} />\n                                        </ListItem>\n                                    ))}\n                                </List>\n                            ) : (\n                                <ListItem\n                                    key={i}\n                                    button\n                                    onClick={() => history.push(`${c.path}`)}\n                                    selected={props.match.url === `${c.path}`}>\n                                    <ListItemText primary={c.title} />\n                                </ListItem>\n                            )\n                        )}\n                    </List>\n                </Drawer>\n            </div>\n            <div className={classes.content}>{props.children}</div>\n        </div>\n    );\n};\n","import React from \"react\";\nimport CssBaseline from \"@material-ui/core/CssBaseline\";\nimport { BrowserRouter, Switch, Route, Redirect } from \"react-router-dom\";\n\nimport Menu from \"./Menu\";\nimport config from \"./config\";\n\nexport default () => (\n    <>\n        <CssBaseline />\n        <BrowserRouter>\n            <Route\n                path=\"*\"\n                component={props => (\n                    <Menu {...props}>\n                        <Switch>\n                            {config.map((c, i) => (\n                                <Route key={i} path={`${c.path}`} component={c.component} />\n                            ))}\n                            <Redirect exact from=\"*\" to={`${config[0].path}`} />\n                        </Switch>\n                    </Menu>\n                )}\n            />\n        </BrowserRouter>\n    </>\n);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://cra.link/PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://cra.link/PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport * as serviceWorkerRegistration from \"./serviceWorkerRegistration\";\n\nReactDOM.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>,\n    document.getElementById(\"root\")\n);\n\nserviceWorkerRegistration.register();\n"],"sourceRoot":""}